{
  "errors": [],
  "warnings": [],
  "version": "4.44.1",
  "hash": "4dc6477fc9606592beaf",
  "time": 347,
  "builtAt": 1598739686989,
  "publicPath": "",
  "outputPath": "/tmp/npmz/shex-validator-user/browser",
  "assetsByChunkName": {
    "shex-webapp-webpack": "shex-webapp-webpack.js",
    "shex-webapp-webpack.min": "shex-webapp-webpack.min.js"
  },
  "assets": [
    {
      "name": "shex-webapp-webpack.js",
      "size": 95787,
      "chunks": [
        0,
        1
      ],
      "chunkNames": [
        "shex-webapp-webpack"
      ],
      "info": {},
      "emitted": true
    },
    {
      "name": "shex-webapp-webpack.min.js",
      "size": 36228,
      "chunks": [
        1,
        0
      ],
      "chunkNames": [
        "shex-webapp-webpack.min"
      ],
      "info": {
        "minimized": true
      },
      "emitted": true
    }
  ],
  "filteredAssets": 0,
  "entrypoints": {
    "shex-webapp-webpack": {
      "chunks": [
        0
      ],
      "assets": [
        "shex-webapp-webpack.js"
      ],
      "children": {},
      "childAssets": {}
    },
    "shex-webapp-webpack.min": {
      "chunks": [
        1
      ],
      "assets": [
        "shex-webapp-webpack.min.js"
      ],
      "children": {},
      "childAssets": {}
    }
  },
  "namedChunkGroups": {
    "shex-webapp-webpack": {
      "chunks": [
        0
      ],
      "assets": [
        "shex-webapp-webpack.js"
      ],
      "children": {},
      "childAssets": {}
    },
    "shex-webapp-webpack.min": {
      "chunks": [
        1
      ],
      "assets": [
        "shex-webapp-webpack.min.js"
      ],
      "children": {},
      "childAssets": {}
    }
  },
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "size": 92421,
      "names": [
        "shex-webapp-webpack"
      ],
      "files": [
        "shex-webapp-webpack.js"
      ],
      "hash": "d49319c33568b21b7b07",
      "siblings": [],
      "parents": [],
      "children": [],
      "childrenByOrder": {},
      "modules": [
        {
          "id": 0,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
          "index": 3,
          "index2": 1,
          "size": 10525,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/term",
              "loc": "31:14-37"
            },
            {
              "moduleId": 5,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "type": "cjs require",
              "userRequest": "@shexjs/term",
              "loc": "2:14-37"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "/**\n *\n * isIRI, isBlank, getLiteralType, getLiteralValue\n */\n\nvar ShExTerm = (function () {\n\n  var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,\n    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,\n    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;\n\n  const RdfLangString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\";\n  const XsdString = \"http://www.w3.org/2001/XMLSchema#string\";\n\n  // N3.js:lib/N3Parser.js<0.4.5>:576 with\n  //   s/this\\./Parser./g\n  //   s/token/iri/\n  // ### `_resolveIRI` resolves a relative IRI token against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative.\n  function resolveRelativeIRI (base, iri) {\n\n    if (absoluteIRI.test(iri))\n      return iri\n\n    switch (iri[0]) {\n    // An empty relative IRI indicates the base IRI\n    case undefined: return base;\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      let m = base.match(schemeAuthority);\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? m[1] : m[0]) + _removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default: {\n      return _removeDotSegments(base.replace(/[^\\/?]*(?:\\?.*)?$/, '') + iri);\n    }\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.\n  function _removeDotSegments (iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!dotSegments.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return result + '/' + iri.substr(i + 1);\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  function internalTerm (node) { // !!rdfjsTermToInternal\n    switch (node.termType) {\n    case (\"NamedNode\"):\n      return node.value;\n    case (\"BlankNode\"):\n      return \"_:\" + node.value;\n    case (\"Literal\"):\n      return \"\\\"\" + node.value + \"\\\"\" + (\n        node.datatypeString === RdfLangString\n          ? \"@\" + node.language\n          : node.datatypeString === XsdString\n          ? \"\"\n          : \"^^\" + node.datatypeString\n      );\n    default: throw Error(\"unknown RDFJS node type: \" + JSON.stringify(node))\n    }\n  }\n\n  function internalTriple (triple) { // !!rdfjsTripleToInternal\n    return {\n      subject: internalTerm(triple.subject),\n      predicate: internalTerm(triple.predicate),\n      object: internalTerm(triple.object)\n    };\n  }\n\n  function externalTerm (node, factory) { // !!intermalTermToRdfjs\n    if (isIRI(node)) {\n      return factory.namedNode(node);\n    } else if (isBlank(node)) {\n      return factory.blankNode(node.substr(2));\n    } else if (isLiteral(node)) {\n      let dtOrLang = getLiteralLanguage(node) ||\n          (getLiteralType(node) === XsdString\n           ? null // seems to screw up N3.js\n           : factory.namedNode(getLiteralType(node)))\n      return factory.literal(getLiteralValue(node), dtOrLang)\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  function externalTriple (triple, factory) { // !!rename internalTripleToRdjs\n    return factory.quad(\n      externalTerm(triple.subject, factory),\n      externalTerm(triple.predicate, factory),\n      externalTerm(triple.object, factory)\n    );\n  }\n\n  function intermalTermToTurtle (node, base, prefixes) {\n    if (isIRI(node)) {\n      // if (node === RDF_TYPE) // only valid in Turtle predicates\n      //   return \"a\";\n\n      // Escape special characters\n      if (escape.test(node))\n        node = node.replace(escapeAll, characterReplacer);\n      var pref = Object.keys(prefixes).find(pref => node.startsWith(prefixes[pref]));\n      if (pref) {\n        var rest = node.substr(prefixes[pref].length);\n        if (rest.indexOf(\"\\\\\") === -1) // could also say no more than n of these: [...]\n          return pref + \":\" + rest.replace(/([~!$&'()*+,;=/?#@%])/g, '\\\\' + \"$1\");\n      }\n      if (node.startsWith(base)) {\n        return \"<\" + node.substr(base.length) + \">\";\n      } else {\n        return \"<\" + node + \">\";\n      }\n    } else if (isBlank(node)) {\n      return node;\n    } else if (isLiteral(node)) {\n      var value = getLiteralValue(node);\n      var type = getLiteralType(node);\n      var language = getLiteralLanguage(node);\n      // Escape special characters\n      if (escape.test(value))\n        value = value.replace(escapeAll, characterReplacer);\n      // Write the literal, possibly with type or language\n      if (language)\n        return '\"' + value + '\"@' + language;\n      else if (type)\n        return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);\n      else\n        return '\"' + value + '\"';\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents an IRI in the N3 library\n  function isIRI (entity) {\n    if (typeof entity !== 'string')\n      return false;\n    else if (entity.length === 0)\n      return true;\n    else {\n      var firstChar = entity[0];\n      return firstChar !== '\"' && firstChar !== '_';\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents a literal in the N3 library\n  function isLiteral (entity) {\n    return typeof entity === 'string' && entity[0] === '\"';\n  }\n\n  // Tests whether the given entity (triple object) represents a blank node in the N3 library\n  function isBlank (entity) {\n    return typeof entity === 'string' && entity.substr(0, 2) === '_:';\n  }\n\n  // Tests whether the given entity represents the default graph\n  function isDefaultGraph (entity) {\n    return !entity;\n  }\n\n  // Tests whether the given triple is in the default graph\n  function inDefaultGraph (triple) {\n    return !triple.graph;\n  }\n\n  // Gets the string value of a literal in the N3 library\n  function getLiteralValue (literal) {\n    var match = /^\"([^]*)\"/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1];\n  }\n\n  // Gets the type of a literal in the N3 library\n  function getLiteralType (literal) {\n    var match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^@\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] || (match[2] ? RdfLangString : XsdString);\n  }\n\n  // Gets the language of a literal in the N3 library\n  function getLiteralLanguage (literal) {\n    var match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] ? match[1].toLowerCase() : '';\n  }\n\n\n// rdf:type predicate (for 'a' abbreviation)\nvar RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    RDF_TYPE   = RDF_PREFIX + 'type';\n\n// Characters in literals that require escaping\nvar escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapeReplacements = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n  // Replaces a character by its escaped version\n  function characterReplacer (character) {\n    // Replace a single character by its escaped version\n    var result = escapeReplacements[character];\n    if (result === undefined) {\n      // Replace a single character with its 4-bit unicode escape sequence\n      if (character.length === 1) {\n        result = character.charCodeAt(0).toString(16);\n        result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n      }\n      // Replace a surrogate pair with its 8-bit unicode escape sequence\n      else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                  character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n    }\n    return result;\n  }\n\n  return {\n    RdfLangString: RdfLangString,\n    XsdString: XsdString,\n    resolveRelativeIRI: resolveRelativeIRI,\n    isIRI: isIRI,\n    isLiteral: isLiteral,\n    isBlank: isBlank,\n    isDefaultGraph: isDefaultGraph,\n    inDefaultGraph: inDefaultGraph,\n    getLiteralValue: getLiteralValue,\n    getLiteralType: getLiteralType,\n    getLiteralLanguage: getLiteralLanguage,\n    internalTerm: internalTerm,\n    internalTriple: internalTriple,\n    externalTerm: externalTerm,\n    externalTriple: externalTriple,\n    intermalTermToTurtle: intermalTermToTurtle,\n  }\n})();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExTerm; // node environment\n"
        },
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "index": 0,
          "index2": 5,
          "size": 71,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "issuerPath": null,
          "profile": {
            "factory": 19,
            "building": 9
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": null,
              "moduleIdentifier": null,
              "module": null,
              "moduleName": null,
              "type": "single entry",
              "userRequest": "./shex-validator-user.js",
              "loc": "shex-webapp-webpack"
            },
            {
              "moduleId": null,
              "moduleIdentifier": null,
              "module": null,
              "moduleName": null,
              "type": "single entry",
              "userRequest": "./shex-validator-user.js",
              "loc": "shex-webapp-webpack.min"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 0,
          "source": "const Validator = require('@shexjs/validator')\nconsole.warn(Validator)\n"
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "index": 1,
          "index2": 4,
          "size": 47946,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "issuerId": 1,
          "issuerName": "./shex-validator-user.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            }
          ],
          "profile": {
            "factory": 5,
            "building": 67
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "module": "./shex-validator-user.js",
              "moduleName": "./shex-validator-user.js",
              "type": "cjs require",
              "userRequest": "@shexjs/validator",
              "loc": "1:18-46"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 1,
          "source": "/* ShExValidator - javascript module to validate a graph with respect to Shape Expressions\n *\n * Status: 1/2 tested, no known bugs.\n *\n * TODO:\n *   constraint violation reporting.\n */\n\nvar ShExValidator = (function () {\nvar UNBOUNDED = -1;\n\n// interface constants\nvar Start = { term: \"START\" }\nvar InterfaceOptions = {\n  \"or\": {\n    \"oneOf\": \"exactly one disjunct must pass\",\n    \"someOf\": \"one or more disjuncts must pass\",\n    \"firstOf\": \"disjunct evaluation stops after one passes\"\n  },\n  \"partition\": {\n    \"greedy\": \"each triple constraint consumes all triples matching predicate and object\",\n    \"exhaustive\": \"search all mappings of triples to triple constriant\"\n  }\n};\n\nvar VERBOSE = \"VERBOSE\" in process.env;\n// **ShExValidator** provides ShEx utility functions\n\nvar ProgramFlowError = { type: \"ProgramFlowError\", errors: { type: \"UntrackedError\" } };\n\nvar RdfTerm = require(\"@shexjs/term\");\nlet ShExVisitor = require(\"@shexjs/visitor\");\n\nfunction getLexicalValue (term) {\n  return RdfTerm.isIRI(term) ? term :\n    RdfTerm.isLiteral(term) ? RdfTerm.getLiteralValue(term) :\n    term.substr(2); // bnodes start with \"_:\"\n}\n\n\nvar XSD = \"http://www.w3.org/2001/XMLSchema#\";\nvar integerDatatypes = [\n  XSD + \"integer\",\n  XSD + \"nonPositiveInteger\",\n  XSD + \"negativeInteger\",\n  XSD + \"long\",\n  XSD + \"int\",\n  XSD + \"short\",\n  XSD + \"byte\",\n  XSD + \"nonNegativeInteger\",\n  XSD + \"unsignedLong\",\n  XSD + \"unsignedInt\",\n  XSD + \"unsignedShort\",\n  XSD + \"unsignedByte\",\n  XSD + \"positiveInteger\"\n];\n\nvar decimalDatatypes = [\n  XSD + \"decimal\",\n].concat(integerDatatypes);\n\nvar numericDatatypes = [\n  XSD + \"float\",\n  XSD + \"double\"\n].concat(decimalDatatypes);\n\nvar numericParsers = {};\nnumericParsers[XSD + \"integer\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?[0-9]+$/))) {\n    parseError(\"illegal integer value '\" + label + \"'\");\n  }\n  return parseInt(label);\n};\nnumericParsers[XSD + \"decimal\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?(?:[0-9]*\\.[0-9]+|[0-9]+)$/))) { // XSD has no pattern for decimal?\n    parseError(\"illegal decimal value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nconst DECIMAL_REGEX = /^[+\\-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[eE][+\\-]?[0-9]+)?$/;\nnumericParsers[XSD + \"float\"  ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) { // XSD has no pattern for float?\n    parseError(\"illegal float value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nnumericParsers[XSD + \"double\" ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) {\n    parseError(\"illegal double value '\" + label + \"'\");\n  }\n  return Number(label);\n};\n\ntestRange = function (value, datatype, parseError) {\n  const ranges = {\n    //    integer            -1 0 1 +1 | \"\" -1.0 +1.0 1e0 NaN INF\n    //    decimal            -1 0 1 +1 -1.0 +1.0 | \"\" 1e0 NaN INF\n    //    float              -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    double             -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    nonPositiveInteger -1 0 +0 -0 | 1 +1 1a a1\n    //    negativeInteger    -1 | 0 +0 -0 1\n    //    long               -1 0 1 +1 |\n    //    int                -1 0 1 +1 |\n    //    short              -32768 0 32767 | -32769 32768\n    //    byte               -128 0 127 | \"\" -129 128\n    //    nonNegativeInteger 0 -0 +0 1 +1 | -1\n    //    unsignedLong       0 1 | -1\n    //    unsignedInt        0 1 | -1\n    //    unsignedShort      0 65535 | -1 65536\n    //    unsignedByte       0 255 | -1 256\n    //    positiveInteger    1 | -1 0\n    //    string             \"\" \"a\" \"0\"\n    //    boolean            true false 0 1 | \"\" TRUE FALSE tRuE fAlSe -1 2 10 01\n    //    dateTime           \"2012-01-02T12:34:56.78Z\" | \"\" \"2012-01-02T\" \"2012-01-02\"\n    integer:            { min: -Infinity           , max: Infinity },\n    decimal:            { min: -Infinity           , max: Infinity },\n    float:              { min: -Infinity           , max: Infinity },\n    double:             { min: -Infinity           , max: Infinity },\n    nonPositiveInteger: { min: -Infinity           , max: 0        },\n    negativeInteger:    { min: -Infinity           , max: -1       },\n    long:               { min: -9223372036854775808, max: 9223372036854775807 },\n    int:                { min: -2147483648         , max: 2147483647 },\n    short:              { min: -32768              , max: 32767    },\n    byte:               { min: -128                , max: 127      },\n    nonNegativeInteger: { min: 0                   , max: Infinity },\n    unsignedLong:       { min: 0                   , max: 18446744073709551615 },\n    unsignedInt:        { min: 0                   , max: 4294967295 },\n    unsignedShort:      { min: 0                   , max: 65535    },\n    unsignedByte:       { min: 0                   , max: 255      },\n    positiveInteger:    { min: 1                   , max: Infinity }\n  }\n  var parms = ranges[datatype.substr(XSD.length)];\n  if (!parms) throw Error(\"unexpected datatype: \" + datatype);\n  if (value < parms.min) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is less than the min:\", parms.min);\n  } else if (value > parms.max) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is greater than the max:\", parms.min);\n  }\n};\n\n/*\nfunction intSubType (spec, label, parseError) {\n  var ret = numericParsers[XSD + \"integer\"](label, parseError);\n  if (\"min\" in spec && ret < spec.min)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be < \" + spec.min);\n  if (\"max\" in spec && ret > spec.max)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be > \" + spec.max);\n  return ret;\n}\n[{type: \"nonPositiveInteger\", max: 0},\n {type: \"negativeInteger\", max: -1},\n {type: \"long\", min: -9223372036854775808, max: 9223372036854775807}, // beyond IEEE double\n {type: \"int\", min: -2147483648, max: 2147483647},\n {type: \"short\", min: -32768, max: 32767},\n {type: \"byte\", min: -128, max: 127},\n {type: \"nonNegativeInteger\", min: 0},\n {type: \"unsignedLong\", min: 0, max: 18446744073709551615},\n {type: \"unsignedInt\", min: 0, max: 4294967295},\n {type: \"unsignedShort\", min: 0, max: 65535},\n {type: \"unsignedByte\", min: 0, max: 255},\n {type: \"positiveInteger\", min: 1}].forEach(function (i) {\n   numericParsers[XSD + i.type ] = function (label, parseError) {\n     return intSubType(i, label, parseError);\n   };\n });\n*/\n\nvar stringTests = {\n  length   : function (v, l) { return v.length === l; },\n  minlength: function (v, l) { return v.length  >= l; },\n  maxlength: function (v, l) { return v.length  <= l; }\n};\n\nvar numericValueTests = {\n  mininclusive  : function (n, m) { return n >= m; },\n  minexclusive  : function (n, m) { return n >  m; },\n  maxinclusive  : function (n, m) { return n <= m; },\n  maxexclusive  : function (n, m) { return n <  m; }\n};\n\nvar decimalLexicalTests = {\n  totaldigits   : function (v, d) {\n    var m = v.match(/[0-9]/g);\n    return m && m.length <= d;\n  },\n  fractiondigits: function (v, d) {\n    var m = v.match(/^[+-]?[0-9]*\\.?([0-9]*)$/);\n    return m && m[1].length <= d;\n  }\n};\n\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n/* ShExValidator_constructor - construct an object for validating a schema.\n *\n * schema: a structure produced by a ShEx parser or equivalent.\n * options: object with controls for\n *   lax(true): boolean: whine about missing types in schema.\n *   diagnose(false): boolean: makde validate return a structure with errors.\n */\nfunction ShExValidator_constructor(schema, options) {\n  if (!(this instanceof ShExValidator_constructor))\n    return new ShExValidator_constructor(schema, options);\n  let index = schema._index || ShExVisitor.index(schema)\n  this.type = \"ShExValidator\";\n  options = options || {};\n  this.options = options;\n  this.options.or = this.options.or || \"someOf\";\n  this.options.partition = this.options.partition || \"exhaustive\";\n  if (!(\"noCache\" in options && options.noCache))\n    this.known = {};\n\n  var _ShExValidator = this;\n  this.schema = schema;\n  this._expect = this.options.lax ? noop : expect; // report errors on missing types.\n  this._optimize = {}; // optimizations:\n    // hasRepeatedGroups: whether there are patterns like (:p1 ., :p2 .)*\n  this.reset = function () {  }; // included in case we need it later.\n  // var regexModule = this.options.regexModule || require(\"@shexjs/eval-simple-1err\");\n  var regexModule = this.options.regexModule || require(\"@shexjs/eval-threaded-nerr\");\n\n  /* getAST - compile a traditional regular expression abstract syntax tree.\n   * Tested but not used at present.\n   */\n  this.getAST = function () {\n    return {\n      type: \"AST\",\n      shapes: schema.shapes.reduce(function (ret, shape) {\n        ret[shape.id] = {\n          type: \"ASTshape\",\n          expression: _compileShapeToAST(shape.expression, [], _ShExValidator.schema)\n        };\n        return ret;\n      }, {})\n    };\n  };\n\n  /* indexTripleConstraints - compile regular expression and index triple constraints\n   */\n  this.indexTripleConstraints = function (expression) {\n    // list of triple constraints from (:p1 ., (:p2 . | :p3 .))\n    var tripleConstraints = [];\n\n    if (expression)\n      indexTripleConstraints_dive(expression);\n    return tripleConstraints;\n\n    function indexTripleConstraints_dive (expr) {\n      if (typeof expr === \"string\") // Inclusion\n        indexTripleConstraints_dive(index.tripleExprs[expr]);\n\n      else if (expr.type === \"TripleConstraint\")\n        tripleConstraints.push(expr)-1;\n\n      else if (expr.type === \"OneOf\" || expr.type === \"EachOf\")\n        expr.expressions.forEach(function (nested) {\n          indexTripleConstraints_dive(nested);\n        });\n\n      // @@TODO shape.virtual, shape.inherit\n      else\n        runtimeError(\"unexpected expr type: \" + expr.type);\n    };\n  };\n\n  /* emptyTracker - a tracker that does nothing\n   */\n  this.emptyTracker = function () {\n    var noop = x => x;\n    return {\n      recurse: noop,\n      known: noop,\n      enter: function (point, label) { ++this.depth; },\n      exit: function (point, label, ret) { --this.depth; },\n      depth: 0\n    };\n  };\n\n  /* validate - test point in db against the schema for labelOrShape\n   * depth: level of recurssion; for logging.\n   */\n  this.validate = function (db, point, label, tracker, seen) {\n    // default to schema's start shape\n    if (typeof point === \"object\" && \"termType\" in point) {\n      point = RdfTerm.internalTerm(point)\n    }\n    if (typeof point === \"object\") {\n      var shapeMap = point;\n      if (this.options.results === \"api\") {\n        return shapeMap.map(pair => {\n          var time = new Date();\n          var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n          time = new Date() - time;\n          return {\n            node: pair.node,\n            shape: pair.shape,\n            status: \"errors\" in res ? \"nonconformant\" : \"conformant\",\n            appinfo: res,\n            elapsed: time\n          };\n        });\n      }\n      var results = shapeMap.reduce((ret, pair) => {\n        var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n        return \"errors\" in res ?\n          { passes: ret.passes, failures: ret.failures.concat(res) } :\n          { passes: ret.passes.concat(res), failures: ret.failures } ;\n      }, {passes: [], failures: []});\n      if (false && this.options.results === \"api\") {\n        var ret = {};\n        function _add (n, s, r) {\n          if (!(n in ret)) {\n            ret[n] = [{shape: s, result: r}];\n            return;\n          }\n          if (ret[n].filter(p => { return p.shape === s; }))\n            return;\n          ret[n].push({shape: s, results: r});\n        }\n        results.passes.forEach(p => { _add(p.node, p.shape, true); });\n        results.failures.forEach(p => { _add(p.node, p.shape, false); });\n        return ret;\n      }\n      if (results.failures.length) {\n        return results.failures.length !== 1 ?\n          { type: \"FailureList\", errors: results.failures } :\n          results.failures [0];\n      } else {\n        return results.passes.length !== 1 ?\n          { type: \"SolutionList\", solutions: results.passes } :\n          results.passes [0];\n      }\n    }\n\n    var outside = tracker === undefined;\n    // logging stuff\n    if (!tracker)\n      tracker = this.emptyTracker();\n    if (!label || label === Start) {\n      if (!schema.start)\n        runtimeError(\"start production not defined\");\n    }\n\n    var shape = null;\n    if (label == Start) {\n      shape = schema.start;\n    } else if (!(\"shapes\" in this.schema) || this.schema.shapes.length === 0) {\n      runtimeError(\"shape \" + label + \" not found; no shapes in schema\");\n    } else if (label in index.shapeExprs) {\n      shape = index.shapeExprs[label]\n    } else {\n      runtimeError(\"shape \" + label + \" not found in:\\n\" + Object.keys(index.shapeExprs || []).map(s => \"  \" + s).join(\"\\n\"));\n    }\n\n    if (seen === undefined)\n      seen = {};\n    var seenKey = point + \"@\" + (label === Start ? \"_: -start-\" : label);\n    if (seenKey in seen)\n      return tracker.recurse({\n        type: \"Recursion\",\n        node: ldify(point),\n        shape: label\n      });\n    if (\"known\" in this && seenKey in this.known)\n      return tracker.known(this.known[seenKey]);\n    seen[seenKey] = { point: point, shape: label };\n    tracker.enter(point, label);\n    var ret = this._validateShapeExpr(db, point, shape, label, tracker, seen);\n    tracker.exit(point, label, ret);\n    delete seen[seenKey];\n    if (\"known\" in this)\n      this.known[seenKey] = ret;\n    if (\"startActs\" in schema && outside) {\n      ret.startActs = schema.startActs;\n    }\n    return ret;\n  }\n\n  this._validateShapeExpr = function (db, point, shapeExpr, shapeLabel, tracker, seen) {\n    if (point === \"\")\n      throw Error(\"validation needs a valid focus node\");\n    if (typeof shapeExpr === \"string\") { // ShapeRef\n      return this._validateShapeExpr(db, point, index.shapeExprs[shapeExpr], shapeExpr, tracker, seen);\n    } else if (shapeExpr.type === \"NodeConstraint\") {\n      var errors = this._errorsMatchingNodeConstraint(point, shapeExpr, null);\n      return errors.length ? {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors.map(function (error) {\n          return {\n            type: \"NodeConstraintViolation\",\n            shapeExpr: shapeExpr,\n            error: error\n          };\n        })\n      } : {\n        type: \"NodeTest\",\n        node: ldify(point),\n        shape: shapeLabel,\n        shapeExpr: shapeExpr\n      };\n    } else if (shapeExpr.type === \"Shape\") {\n      return this._validateShape(db, point, regexModule.compile(schema, shapeExpr, index),\n                                 shapeExpr, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeExternal\") {\n      return this.options.validateExtern(db, point, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeOr\") {\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          return { type: \"ShapeOrResults\", solution: sub };\n      }\n      return { type: \"ShapeOrFailure\", errors: errors };\n    } else if (shapeExpr.type === \"ShapeNot\") {\n      var sub = this._validateShapeExpr(db, point, shapeExpr.shapeExpr, shapeLabel, tracker, seen);\n      if (\"errors\" in sub)\n          return { type: \"ShapeNotResults\", solution: sub };\n        else\n          return { type: \"ShapeNotFailure\", errors: sub };\n    } else if (shapeExpr.type === \"ShapeAnd\") {\n      var passes = [];\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          passes.push(sub);\n      }\n      if (errors.length > 0) {\n        return  { type: \"ShapeAndFailure\", errors: errors};\n      }\n      return { type: \"ShapeAndResults\", solutions: passes };\n    } else\n      throw Error(\"expected one of Shape{Ref,And,Or} or NodeConstraint, got \" + JSON.stringify(shapeExpr));\n  }\n\n  this._validateShape = function (db, point, regexEngine, shape, shapeLabel, tracker, seen) {\n    var _ShExValidator = this;\n\n    var ret = null;\n    var startAcionStorage = {}; // !!! need test to see this write to results structure.\n    if (\"startActs\" in schema) {\n      const semActErrors = this.semActHandler.dispatchAll(schema.startActs, null, startAcionStorage)\n      if (semActErrors.length)\n        return {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: semActErrors\n        }; // some semAct aborted !! return real error\n    }\n    // @@ add to tracker: f(\"validating <\" + point + \"> as <\" + shapeLabel + \">\");\n\n    var fromDB  = db.getNeighborhood(point, shapeLabel, shape);\n    var outgoing = indexNeighborhood(fromDB.outgoing.sort(\n      (l, r) => sparqlOrder(l.object, r.object)\n    ));\n    var incoming = indexNeighborhood(fromDB.incoming.sort(\n      (l, r) => sparqlOrder(l.subject, r.subject)\n    ));\n    var outgoingLength = fromDB.outgoing.length;\n    var neighborhood = fromDB.outgoing.concat(fromDB.incoming);\n\n    var constraintList = this.indexTripleConstraints(shape.expression);\n    var tripleList = constraintList.reduce(function (ret, constraint, ord) {\n\n      // subject and object depend on direction of constraint.\n      var searchSubject = constraint.inverse ? null : point;\n      var searchObject = constraint.inverse ? point : null;\n      var index = constraint.inverse ? incoming : outgoing;\n\n      // get triples matching predciate\n      var matchPredicate = index.byPredicate[constraint.predicate] ||\n        []; // empty list when no triple matches that constraint\n\n      function _errorsByShapeLabel (focus, shapeLabel) {\n        var sub = _ShExValidator.validate(db, focus, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      function _errorsByShapeExpr (focus, shapeExpr) {\n        var sub = _ShExValidator._validateShapeExpr(db, focus, shapeExpr, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      // strip to triples matching value constraints (apart from @<someShape>)\n      var matchConstraints = _ShExValidator._triplesMatchingShapeExpr(\n        matchPredicate,\n        constraint.valueExpr,\n        constraint.inverse,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeLabel,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeExpr\n      );\n\n      matchConstraints.hits.forEach(function (t) {\n        ret.constraintList[neighborhood.indexOf(t)].push(ord);\n      });\n      matchConstraints.misses.forEach(function (t) {\n        ret.misses[neighborhood.indexOf(t.triple)] = {constraintNo: ord, errors: t.errors};\n      });\n      return ret;\n    }, { misses: {}, constraintList:_seq(neighborhood.length).map(function () { return []; }) }); // start with [[],[]...]\n\n    // @@ add to tracker: f(\"constraints by triple: \", JSON.stringify(tripleList.constraintList));\n\n    var extras = []; // triples accounted for by EXTRA\n    var misses = tripleList.constraintList.reduce(function (ret, constraints, ord) {\n      if (constraints.length === 0 &&                       // matches no constraints\n          ord < outgoingLength &&                           // not an incoming triple\n          ord in tripleList.misses) {                       // predicate matched some constraint(s)\n        if (shape.extra !== undefined &&\n            shape.extra.indexOf(neighborhood[ord].predicate) !== -1) {\n          extras.push(ord);\n        } else {                                            // not declared extra\n          ret.push({                                        // so it's a missed triple.\n            tripleNo: ord,\n            constraintNo: tripleList.misses[ord].constraintNo,\n            errors: tripleList.misses[ord].errors\n          });\n        }\n      }\n      return ret;\n    }, []);\n\n    var xp = crossProduct(tripleList.constraintList);\n    var partitionErrors = [];\n    while ((misses.length === 0 || this.options.partition !== \"greedy\") && xp.next() && ret === null) {\n      // caution: early continues\n\n      var usedTriples = []; // [{s1,p1,o1},{s2,p2,o2}] implicated triples -- used for messages\n      var constraintMatchCount = // [2,1,0,1] how many triples matched a constraint\n        _seq(neighborhood.length).map(function () { return 0; });\n      var tripleToConstraintMapping = xp.get(); // [0,1,0,3] mapping from triple to constraint\n\n      // Triples not mapped to triple constraints are not allowed in closed shapes.\n      if (shape.closed) {\n        var unexpectedTriples = neighborhood.slice(0, outgoingLength).filter((t, i) => {\n          return tripleToConstraintMapping[i] === undefined && // didn't match a constraint\n          extras.indexOf(i) === -1; // wasn't in EXTRAs.\n        });\n        if (unexpectedTriples.length > 0) {\n          partitionErrors.push({\n            errors: [\n              {\n                type: \"ClosedShapeViolation\",\n                unexpectedTriples: unexpectedTriples\n              }\n            ]\n          });\n          continue; // closed shape violation.\n        }\n      }\n\n      // Set usedTriples and constraintMatchCount.\n      tripleToConstraintMapping.forEach(function (tpNumber, ord) {\n        if (tpNumber !== undefined) {\n          usedTriples.push(neighborhood[ord]);\n          ++constraintMatchCount[tpNumber];\n        }\n      });\n\n      // Pivot to triples by constraint.\n      function _constraintToTriples () {\n        var cll = constraintList.length;\n        return tripleToConstraintMapping.slice().\n          reduce(function (ret, c, ord) {\n            if (c !== undefined)\n              ret[c].push(ord);\n            return ret;\n          }, _seq(cll).map(function () { return []; }));\n      }\n\n      tripleToConstraintMapping.slice().sort(function (a,b) { return a-b; }).filter(function (i) { // sort constraint numbers\n        return i !== undefined;\n      }).map(function (n) { return n + \" \"; }).join(\"\"); // e.g. 0 0 1 3\n\n      function _recurse (point, shapeLabel) {\n        return _ShExValidator.validate(db, point, shapeLabel, tracker, seen);\n      }\n      function _direct (point, shapeExpr) {\n        return _ShExValidator._validateShapeExpr(db, point, shapeExpr, shapeLabel, tracker, seen);\n      }\n      function _testExpr (term, valueExpr, recurse, direct) {\n        return _ShExValidator._errorsMatchingShapeExpr(term, valueExpr, recurse, direct)\n      }\n      var results = regexEngine.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, _direct, this.semActHandler, _testExpr, null);\n      // {// testing parity between two engines\n      //   var nfa = require(\"@shexjs/eval-simple-1err\").compile(schema, shape);\n      //   var fromNFA = nfa.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, this.semActHandler, _testExpr, null);\n      //   if (\"errors\" in fromNFA !== \"errors\" in results)\n      //     { throw Error(JSON.stringify(results) + \" vs \" + JSON.stringify(fromNFA)); }\n      // }\n      if (\"errors\" in results) {\n        partitionErrors.push({\n          errors: results.errors\n        });\n        if (_ShExValidator.options.partition !== \"exhaustive\")\n          break;\n        else\n          continue;\n      }\n\n      // @@ add to tracker: f(\"post-regexp \" + usedTriples.join(\" \"));\n\n      var possibleRet = { type: \"ShapeTest\", node: ldify(point), shape: shapeLabel };\n      if (Object.keys(results).length > 0) // only include .solution for non-empty pattern\n        possibleRet.solution = results;\n      if (\"semActs\" in shape) {\n        const semActErrors = this.semActHandler.dispatchAll(shape.semActs, results, possibleRet)\n        if (semActErrors.length) {\n          // some semAct aborted\n          partitionErrors.push({\n            errors: semActErrors\n          });\n          if (_ShExValidator.options.partition !== \"exhaustive\")\n            break;\n          else\n            continue;\n        }\n      }\n      // @@ add to tracker: f(\"final \" + usedTriples.join(\" \"));\n\n      ret = possibleRet;\n      partitionErrors = [];\n      // alts.push(tripleToConstraintMapping);\n    }\n    var missErrors = misses.map(function (miss) {\n      var t = neighborhood[miss.tripleNo];\n      return {\n        type: \"TypeMismatch\",\n        triple: {type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)},\n        constraint: constraintList[miss.constraintNo],\n        errors: miss.errors\n      };\n    });\n    let errors = missErrors.concat(partitionErrors.length === 1 ? partitionErrors[0].errors : partitionErrors);\n    if (errors.length > 0) {\n      ret = {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors\n      };\n    }\n\n    if (VERBOSE) { // remove N3jsTripleToString\n      neighborhood.forEach(function (t) {\n        delete t.toString;\n      });\n    }\n    // @@ add to tracker: f(\"</\" + shapeLabel + \">\");\n    return addShapeAttributes(ret);\n\n    function addShapeAttributes (ret) {\n      if (\"annotations\" in shape)\n        ret.annotations = shape.annotations;\n      return ret;\n    }\n  };\n\n  this._triplesMatchingShapeExpr = function (triples, valueExpr, inverse, recurse, direct) {\n    var _ShExValidator = this;\n    var misses = [];\n    var hits = [];\n    triples.forEach(function (triple) {\n      var value = inverse ? triple.subject : triple.object;\n      var errors = valueExpr === undefined ?\n          [] :\n          _ShExValidator._errorsMatchingShapeExpr(value, valueExpr, recurse, direct);\n      if (errors.length === 0) {\n        hits.push(triple);\n      } else if (hits.indexOf(triple) === -1) {\n        misses.push({triple: triple, errors: errors});\n      }\n    });\n    return { hits: hits, misses: misses };\n  }\n  this._errorsMatchingShapeExpr = function (value, valueExpr, recurse, direct) {\n    var _ShExValidator = this;\n    if (typeof valueExpr === \"string\") { // ShapeRef\n      return recurse ? recurse(value, valueExpr) : [];\n    } else if (valueExpr.type === \"NodeConstraint\") {\n      return this._errorsMatchingNodeConstraint(value, valueExpr, null);\n    } else if (valueExpr.type === \"Shape\") {\n      return direct === undefined ? [] : direct(value, valueExpr);\n    } else if (valueExpr.type === \"ShapeOr\") {\n      var ret = [];\n      for (var i = 0; i < valueExpr.shapeExprs.length; ++i) {\n        var nested = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExprs[i], recurse, direct);\n        if (nested.length === 0)\n          return nested;\n        ret = ret.concat(nested);\n      }\n      return ret;\n    } else if (valueExpr.type === \"ShapeAnd\") {\n      return valueExpr.shapeExprs.reduce(function (ret, nested, iter) {\n        return ret.concat(_ShExValidator._errorsMatchingShapeExpr(value, nested, recurse, direct, true));\n      }, []);\n    } else if (valueExpr.type === \"ShapeNot\") {\n      var ret = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExpr, recurse, direct, true);\n      return ret.length ?\n        [] :\n        [\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": expected NOT to pass\"];\n    } else {\n      throw Error(\"unknown value expression type '\" + valueExpr.type + \"'\");\n    }\n  };\n\n  /* _errorsMatchingNodeConstraint - return whether the value matches the value\n   * expression without checking shape references.\n   */\n  this._errorsMatchingNodeConstraint = function (value, valueExpr, recurse) {\n    var errors = [];\n    var label = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralValue(value) :\n      RdfTerm.isBlank(value) ? value.substring(2) :\n      value;\n    var dt = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralType(value) : null;\n    var numeric = integerDatatypes.indexOf(dt) !== -1 ? XSD + \"integer\" : numericDatatypes.indexOf(dt) !== -1 ? dt : undefined;\n\n    function validationError () {\n      var errorStr = Array.prototype.join.call(arguments, \"\");\n      errors.push(\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": \" + errorStr);\n      return false;\n    }\n    // if (negated) ;\n    if (false) {\n      // wildcard -- ignore\n    } else {\n      if (\"nodeKind\" in valueExpr) {\n        if ([\"iri\", \"bnode\", \"literal\", \"nonliteral\"].indexOf(valueExpr.nodeKind) === -1) {\n          validationError(\"unknown node kind '\" + valueExpr.nodeKind + \"'\");\n        }\n        if (RdfTerm.isBlank(value)) {\n          if (valueExpr.nodeKind === \"iri\" || valueExpr.nodeKind === \"literal\") {\n            validationError(\"blank node found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (RdfTerm.isLiteral(value)) {\n          if (valueExpr.nodeKind !== \"literal\") {\n            validationError(\"literal found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (valueExpr.nodeKind === \"bnode\" || valueExpr.nodeKind === \"literal\") {\n          validationError(\"iri found when \" + valueExpr.nodeKind + \" expected\");\n        }\n      }\n\n      if (valueExpr.datatype  && valueExpr.values  ) validationError(\"found both datatype and values in \"   +tripleConstraint);\n\n      if (valueExpr.datatype) {\n        if (!RdfTerm.isLiteral(value)) {\n          validationError(\"mismatched datatype: \" + value + \" is not a literal with datatype \" + valueExpr.datatype);\n        }\n        else if (RdfTerm.getLiteralType(value) !== valueExpr.datatype) {\n          validationError(\"mismatched datatype: \" + RdfTerm.getLiteralType(value) + \" !== \" + valueExpr.datatype);\n        }\n        else if (numeric) {\n          testRange(numericParsers[numeric](label, validationError), valueExpr.datatype, validationError);\n        }\n        else if (valueExpr.datatype === XSD + \"boolean\") {\n          if (label !== \"true\" && label !== \"false\" && label !== \"1\" && label !== \"0\")\n            validationError(\"illegal boolean value: \" + label);\n        }\n        else if (valueExpr.datatype === XSD + \"dateTime\") {\n          if (!label.match(/^[+-]?\\d{4}-[01]\\d-[0-3]\\dT[0-5]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?([+-][0-2]\\d:[0-5]\\d|Z)?$/))\n            validationError(\"illegal dateTime value: \" + label);\n        }\n      }\n\n      if (valueExpr.values) {\n        if (RdfTerm.isLiteral(value) && valueExpr.values.reduce((ret, v) => {\n          if (ret) return true;\n          var ld = ldify(value);\n          if (v.type === \"Language\") {\n            return v.languageTag === ld.language; // @@ use equals/normalizeTest\n          }\n          if (!(typeof v === \"object\" && \"value\" in v))\n            return false;\n          return v.value === ld.value &&\n            v.type === ld.type &&\n            v.language === ld.language;\n        }, false)) {\n          // literal match\n        } else if (valueExpr.values.indexOf(value) !== -1) {\n          // trivial match\n        } else {\n          if (!(valueExpr.values.some(function (valueConstraint) {\n            if (typeof valueConstraint === \"object\" && !(\"value\" in valueConstraint)) { // isTerm me -- strike \"value\" in\n              if (!(\"type\" in valueConstraint))\n                runtimeError(\"expected \"+JSON.stringify(valueConstraint)+\" to have a 'type' attribute.\");\n              var stemRangeTypes = [\n                \"Language\",\n                \"IriStem\",      \"LiteralStem\",      \"LanguageStem\",\n                \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"\n              ];\n              if (stemRangeTypes.indexOf(valueConstraint.type) === -1)\n                runtimeError(\"expected type attribute '\"+valueConstraint.type+\"' to be in '\"+stemRangeTypes+\"'.\");\n\n              /* expect N3.js literals with {Literal,Language}StemRange\n               *       or non-literals with IriStemRange\n               */\n              function normalizedTest (val, ref, func) {\n                if (RdfTerm.isLiteral(val)) {\n                  if ([\"LiteralStem\", \"LiteralStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralValue(val), ref);\n                  } else if ([\"LanguageStem\", \"LanguageStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralLanguage(val) || null, ref);\n                  } else {\n                    return validationError(\"literal \" + val + \" not comparable with non-literal \" + ref);\n                  }\n                } else {\n                  if ([\"IriStem\", \"IriStemRange\"].indexOf(valueConstraint.type) === -1) {\n                    return validationError(\"nonliteral \" + val + \" not comparable with literal \" + JSON.stringify(ref));\n                  } else {\n                    return func(val, ref);\n                  }\n                }\n              }\n              function startsWith (val, ref) {\n                return normalizedTest(val, ref, (l, r) => {\n                  return (valueConstraint.type === \"LanguageStem\" ||\n                          valueConstraint.type === \"LanguageStemRange\") ?\n                    // rfc4647 basic filtering\n                    l !== null && (l === r || r === \"\" || l[r.length] === \"-\") :\n                    // simple substring\n                    l.startsWith(r);\n                });\n              }\n              function equals (val, ref) {\n                return normalizedTest(val, ref, (l, r) => { return l === r; });\n              }\n\n              if (!isTerm(valueConstraint.stem)) {\n                expect(valueConstraint.stem, \"type\", \"Wildcard\");\n                // match whatever but check exclusions below\n              } else {\n                if (!(startsWith(value, valueConstraint.stem))) {\n                  return false;\n                }\n              }\n              if (valueConstraint.exclusions) {\n                return !valueConstraint.exclusions.some(function (c) {\n                  if (!isTerm(c)) {\n                    if (!(\"type\" in c))\n                      runtimeError(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\");\n                    var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n                    if (stemTypes.indexOf(c.type) === -1)\n                      runtimeError(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\");\n                    return startsWith(value, c.stem);\n                  } else {\n                    return equals(value, c);\n                  }\n                });\n              }\n              return true;\n            } else {\n              // ignore -- would have caught it above\n            }\n          }))) {\n            validationError(\"value \" + value + \" not found in set \" + JSON.stringify(valueExpr.values));\n          }\n        }\n      }\n    }\n\n    if (\"pattern\" in valueExpr) {\n      var regexp = \"flags\" in valueExpr ?\n\t  new RegExp(valueExpr.pattern, valueExpr.flags) :\n\t  new RegExp(valueExpr.pattern);\n      if (!(getLexicalValue(value).match(regexp)))\n        validationError(\"value \" + getLexicalValue(value) + \" did not match pattern \" + valueExpr.pattern);\n    }\n\n    Object.keys(stringTests).forEach(function (test) {\n      if (test in valueExpr && !stringTests[test](label, valueExpr[test])) {\n        validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n      }\n    });\n\n    Object.keys(numericValueTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric) {\n          if (!numericValueTests[test](numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n\n    Object.keys(decimalLexicalTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric === XSD + \"integer\" || numeric === XSD + \"decimal\") {\n          if (!decimalLexicalTests[test](\"\"+numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n    return errors;\n  };\n\n  this.semActHandler = {\n    handlers: { },\n    results: { },\n    /**\n     * Store a semantic action handler.\n     *\n     * @param {string} name - semantic action's URL.\n     * @param {object} handler - handler function.\n     *\n     * The handler object has a dispatch function is invoked with:\n     * @param {string} code - text of the semantic action.\n     * @param {object} ctx - matched triple or results subset.\n     * @param {object} extensionStorage - place where the extension writes into the result structure.\n     * @return {bool} false if the extension failed or did not accept the ctx object.\n     */\n    register: function (name, handler) {\n      this.handlers[name] = handler;\n    },\n    /**\n     * Calls all semantic actions, allowing each to write to resultsArtifact.\n     *\n     * @param {array} semActs - list of semantic actions to invoke.\n     * @return {bool} false if any result was false.\n     */\n    dispatchAll: function (semActs, ctx, resultsArtifact) {\n      var _semActHanlder = this;\n      return semActs.reduce(function (ret, semAct) {\n        if (ret.length === 0 && semAct.name in _semActHanlder.handlers) {\n          var code = \"code\" in semAct ? semAct.code : _ShExValidator.options.semActs[semAct.name];\n          var existing = \"extensions\" in resultsArtifact && semAct.name in resultsArtifact.extensions;\n          var extensionStorage = existing ? resultsArtifact.extensions[semAct.name] : {};\n          const response = _semActHanlder.handlers[semAct.name].dispatch(code, ctx, extensionStorage); debugger\n          if (typeof response === 'boolean') {\n            if (!response)\n              ret.push({ type: \"SemActFailure\", errors: [{ type: \"BooleanSemActFailure\", code: code, ctx }] })\n          } else if (typeof response === 'object' && response.constructor === Array) {\n            if (response.length > 0)\n              ret.push({ type: \"SemActFailure\", errors: response })\n          } else {\n            throw Error(\"unsupported response from semantic action handler: \" + JSON.stringify(response))\n          }\n          if (!existing && Object.keys(extensionStorage).length > 0) {\n            if (!(\"extensions\" in resultsArtifact))\n              resultsArtifact.extensions = {};\n            resultsArtifact.extensions[semAct.name] = extensionStorage;\n          }\n          return ret;\n        }\n        return ret;\n      }, []);\n    }\n  };\n}\n\n/* _compileShapeToAST - compile a shape expression to an abstract syntax tree.\n *\n * currently tested but not used.\n */\nfunction _compileShapeToAST (expression, tripleConstraints, schema) {\n\n  function Epsilon () {\n    this.type = \"Epsilon\";\n  }\n\n  function TripleConstraint (ordinal, predicate, inverse, negated, valueExpr) {\n    this.type = \"TripleConstraint\";\n    // this.ordinal = ordinal; @@ does 1card25\n    this.inverse = !!inverse;\n    this.negated = !!negated;\n    this.predicate = predicate;\n    if (valueExpr !== undefined)\n      this.valueExpr = valueExpr;\n  }\n\n  function Choice (disjuncts) {\n    this.type = \"Choice\";\n    this.disjuncts = disjuncts;\n  }\n\n  function EachOf (conjuncts) {\n    this.type = \"EachOf\";\n    this.conjuncts = conjuncts;\n  }\n\n  function SemActs (expression, semActs) {\n    this.type = \"SemActs\";\n    this.expression = expression;\n    this.semActs = semActs;\n  }\n\n  function KleeneStar (expression) {\n    this.type = \"KleeneStar\";\n    this.expression = expression;\n  }\n\n  function _compileExpression (expr, schema) {\n    var repeated, container;\n\n    /* _repeat: map expr with a min and max cardinality to a corresponding AST with Groups and Stars.\n       expr 1 1 => expr\n       expr 0 1 => Choice(expr, Eps)\n       expr 0 3 => Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps)\n       expr 2 5 => EachOf(expr, expr, Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps))\n       expr 0 * => KleeneStar(expr)\n       expr 1 * => EachOf(expr, KleeneStar(expr))\n       expr 2 * => EachOf(expr, expr, KleeneStar(expr))\n\n       @@TODO: favor Plus over Star if Epsilon not in expr.\n    */\n    function _repeat (expr, min, max) {\n      if (min === undefined) { min = 1; }\n      if (max === undefined) { max = 1; }\n\n      if (min === 1 && max === 1) { return expr; }\n\n      var opts = max === UNBOUNDED ?\n        new KleeneStar(expr) :\n        _seq(max - min).reduce(function (ret, elt, ord) {\n          return ord === 0 ?\n            new Choice([expr, new Epsilon]) :\n            new Choice([new EachOf([expr, ret]), new Epsilon]);\n        }, undefined);\n\n      var reqd = min !== 0 ?\n        new EachOf(_seq(min).map(function (ret) {\n          return expr; // @@ something with ret\n        }).concat(opts)) : opts;\n      return reqd;\n    }\n\n    if (typeof expr === \"string\") { // Inclusion\n      var included = schema._index.tripleExprs[expr].expression;\n      return _compileExpression(included, schema);\n    }\n\n    else if (expr.type === \"TripleConstraint\") {\n      // predicate, inverse, negated, valueExpr, annotations, semActs, min, max\n      var valueExpr = \"valueExprRef\" in expr ?\n        schema.valueExprDefns[expr.valueExprRef] :\n        expr.valueExpr;\n      var ordinal = tripleConstraints.push(expr)-1;\n      var tp = new TripleConstraint(ordinal, expr.predicate, expr.inverse, expr.negated, valueExpr);\n      repeated = _repeat(tp, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"OneOf\") {\n      container = new Choice(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"EachOf\") {\n      container = new EachOf(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else throw Error(\"unexpected expr type: \" + expr.type);\n  }\n\n  return expression ? _compileExpression(expression, schema) : new Epsilon();\n}\n\n// http://stackoverflow.com/questions/9422386/lazy-cartesian-product-of-arrays-arbitrary-nested-loops\nfunction crossProduct(sets) {\n  var n = sets.length, carets = [], args = null;\n\n  function init() {\n    args = [];\n    for (var i = 0; i < n; i++) {\n      carets[i] = 0;\n      args[i] = sets[i][0];\n    }\n  }\n\n  function next() {\n\n    // special case: crossProduct([]).next().next() returns false.\n    if (args !== null && args.length === 0)\n      return false;\n\n    if (args === null) {\n      init();\n      return true;\n    }\n    var i = n - 1;\n    carets[i]++;\n    if (carets[i] < sets[i].length) {\n      args[i] = sets[i][carets[i]];\n      return true;\n    }\n    while (carets[i] >= sets[i].length) {\n      if (i == 0) {\n        return false;\n      }\n      carets[i] = 0;\n      args[i] = sets[i][0];\n      carets[--i]++;\n    }\n    args[i] = sets[i][carets[i]];\n    return true;\n  }\n\n  return {\n    next: next,\n    do: function (block, _context) { // old API\n      return block.apply(_context, args);\n    },\n    // new API because\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description\n    // cautions about functions over arguments.\n    get: function () { return args; }\n  };\n}\n\n/* N3jsTripleToString - simple toString function to make N3.js's triples\n * printable.\n */\nvar N3jsTripleToString = function () {\n  function fmt (n) {\n    return RdfTerm.isLiteral(n) ?\n      [ \"http://www.w3.org/2001/XMLSchema#integer\",\n        \"http://www.w3.org/2001/XMLSchema#float\",\n        \"http://www.w3.org/2001/XMLSchema#double\"\n      ].indexOf(RdfTerm.getLiteralType(n)) !== -1 ?\n      parseInt(RdfTerm.getLiteralValue(n)) :\n      n :\n    RdfTerm.isBlank(n) ?\n      n :\n      \"<\" + n + \">\";\n  }\n  return fmt(this.subject) + \" \" + fmt(this.predicate) + \" \" + fmt(this.object) + \" .\";\n};\n\n/* indexNeighborhood - index triples by predicate\n * returns: {\n *     byPredicate: Object: mapping from predicate to triples containing that\n *                  predicate.\n *\n *     candidates: [[1,3], [0,2]]: mapping from triple to the triple constraints\n *                 it matches.  It is initialized to []. Mappings that remain an\n *                 empty set indicate a triple which didn't matching anything in\n *                 the shape.\n *\n *     misses: list to recieve value constraint failures.\n *   }\n */\nfunction indexNeighborhood (triples) {\n  return {\n    byPredicate: triples.reduce(function (ret, t) {\n      var p = t.predicate;\n      if (!(p in ret))\n        ret[p] = [];\n      ret[p].push(t);\n\n      // If in VERBOSE mode, add a nice toString to N3.js's triple objects.\n      if (VERBOSE)\n        t.toString = N3jsTripleToString;\n\n      return ret;\n    }, {}),\n    candidates: _seq(triples.length).map(function () {\n      return [];\n    }),\n    misses: []\n  };\n}\n\n/* sparqlOrder - sort triples by subject following SPARQL partial ordering.\n */\nfunction sparqlOrder (l, r) {\n  var [lprec, rprec] = [l, r].map(\n    x => RdfTerm.isBlank(x) ? 1 : RdfTerm.isLiteral(x) ? 2 : 3\n  );\n  return lprec === rprec ? l.localeCompare(r) : lprec - rprec;\n}\n\n/* Return a list of n \"\"s.\n *\n * Note that Array(n) on its own returns a \"sparse array\" so Array(n).map(f)\n * never calls f.\n */\nfunction _seq (n) {\n  return n === 0 ?\n    [] :\n    Array(n).join(\" \").split(/ /); // hahaha, javascript, you suck.\n}\n\n/* Expect property p with value v in object o\n */\nfunction expect (o, p, v) {\n  if (!(p in o))\n    runtimeError(\"expected \"+JSON.stringify(o)+\" to have a '\"+p+\"' attribute.\");\n  if (arguments.length > 2 && o[p] !== v)\n    runtimeError(\"expected \"+p+\" attribute '\"+o[p]+\"' to equal '\"+v+\"'.\");\n}\n\nfunction noop () {  }\n\nfunction runtimeError () {\n  var errorStr = Array.prototype.join.call(arguments, \"\");\n  var e = new Error(errorStr);\n  Error.captureStackTrace(e, runtimeError);\n  throw e;\n}\n\n  return {\n    construct: ShExValidator_constructor,\n    start: Start,\n    options: InterfaceOptions\n  };\n})();\n\n// Export the `ShExValidator` class as a whole.\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = ShExValidator;\n"
        },
        {
          "id": 3,
          "identifier": "/tmp/npmz/shex-validator-user/node_modules/process/browser.js",
          "name": "./node_modules/process/browser.js",
          "index": 2,
          "index2": 0,
          "size": 5418,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "process",
              "loc": "1:0-84"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"
        },
        {
          "id": 4,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
          "index": 4,
          "index2": 2,
          "size": 13166,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/visitor",
              "loc": "32:18-44"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n  function isShapeRef (expr) {\n    return typeof expr === \"string\" // test for JSON-LD @ID\n  }\n  let isInclusion = isShapeRef;\n\n\nfunction ShExVisitor () {\n  // function expect (l, r) { var ls = JSON.stringify(l), rs = JSON.stringify(r); if (ls !== rs) throw Error(ls+\" !== \"+rs); }\n  var _ShExUtil = this;\n  function visitMap (map, val) {\n    var ret = {};\n    Object.keys(map).forEach(function (item) {\n      ret[item] = val(map[item]);\n    });\n    return ret;\n  }\n  var r = {\n    runtimeError: function (e) {\n      throw e;\n    },\n\n    visitSchema: function (schema) {\n      var ret = { type: \"Schema\" };\n      _expect(schema, \"type\", \"Schema\");\n      this._maybeSet(schema, ret, \"Schema\",\n                     [\"@context\", \"prefixes\", \"base\", \"imports\", \"startActs\", \"start\", \"shapes\"],\n                     [\"_base\", \"_prefixes\", \"_index\", \"_sourceMap\"]\n                    );\n      return ret;\n    },\n\n    visitPrefixes: function (prefixes) {\n      return prefixes === undefined ?\n        undefined :\n        visitMap(prefixes, function (val) {\n          return val;\n        });\n    },\n\n    visitIRI: function (i) {\n      return i;\n    },\n\n    visitImports: function (imports) {\n      var _Visitor = this;\n      return imports.map(function (imp) {\n        return _Visitor.visitIRI(imp);\n      });\n    },\n\n    visitStartActs: function (startActs) {\n      var _Visitor = this;\n      return startActs === undefined ?\n        undefined :\n        startActs.map(function (act) {\n          return _Visitor.visitSemAct(act);\n        });\n    },\n    visitSemActs: function (semActs) {\n      var _Visitor = this;\n      if (semActs === undefined)\n        return undefined;\n      var ret = []\n      Object.keys(semActs).forEach(function (label) {\n        ret.push(_Visitor.visitSemAct(semActs[label], label));\n      });\n      return ret;\n    },\n    visitSemAct: function (semAct, label) {\n      var ret = { type: \"SemAct\" };\n      _expect(semAct, \"type\", \"SemAct\");\n\n      this._maybeSet(semAct, ret, \"SemAct\",\n                     [\"name\", \"code\"]);\n      return ret;\n    },\n\n    visitShapes: function (shapes) {\n      var _Visitor = this;\n      if (shapes === undefined)\n        return undefined;\n      return shapes.map(\n        shapeExpr =>\n          _Visitor.visitShapeExpr(shapeExpr)\n      );\n    },\n\n    visitProductions999: function (productions) { // !! DELETE\n      var _Visitor = this;\n      if (productions === undefined)\n        return undefined;\n      var ret = {}\n      Object.keys(productions).forEach(function (label) {\n        ret[label] = _Visitor.visitExpression(productions[label], label);\n      });\n      return ret;\n    },\n\n    visitShapeExpr: function (expr, label) {\n      if (isShapeRef(expr))\n        return this.visitShapeRef(expr)\n      var r =\n          expr.type === \"Shape\" ? this.visitShape(expr, label) :\n          expr.type === \"NodeConstraint\" ? this.visitNodeConstraint(expr, label) :\n          expr.type === \"ShapeAnd\" ? this.visitShapeAnd(expr, label) :\n          expr.type === \"ShapeOr\" ? this.visitShapeOr(expr, label) :\n          expr.type === \"ShapeNot\" ? this.visitShapeNot(expr, label) :\n          expr.type === \"ShapeExternal\" ? this.visitShapeExternal(expr) :\n          null;// if (expr.type === \"ShapeRef\") r = 0; // console.warn(\"visitShapeExpr:\", r);\n      if (r === null)\n        throw Error(\"unexpected shapeExpr type: \" + expr.type);\n      else\n        return r;\n    },\n\n    // _visitShapeGroup: visit a grouping expression (shapeAnd, shapeOr)\n    _visitShapeGroup: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExprs\"], expr.type, this.visitShapeNot)\n      var _Visitor = this;\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExprs = expr.shapeExprs.map(function (nested) {\n        return _Visitor.visitShapeExpr(nested, label);\n      });\n      return r;\n    },\n\n    // _visitShapeNot: visit negated shape\n    visitShapeNot: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExpr\"], \"ShapeNot\", this.visitShapeNot)\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExpr = this.visitShapeExpr(expr.shapeExpr, label);\n      return r;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitShape: function (shape, label) {\n      var ret = { type: \"Shape\" };\n      _expect(shape, \"type\", \"Shape\");\n\n      this._maybeSet(shape, ret, \"Shape\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"closed\",\n                       \"expression\", \"extra\", \"semActs\", \"annotations\"]);\n      return ret;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitNodeConstraint: function (shape, label) {\n      var ret = { type: \"NodeConstraint\" };\n      _expect(shape, \"type\", \"NodeConstraint\");\n\n      this._maybeSet(shape, ret, \"NodeConstraint\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"nodeKind\", \"datatype\", \"pattern\", \"flags\", \"length\",\n                       \"reference\", \"minlength\", \"maxlength\",\n                       \"mininclusive\", \"minexclusive\", \"maxinclusive\", \"maxexclusive\",\n                       \"totaldigits\", \"fractiondigits\", \"values\", \"annotations\", \"semActs\"]);\n      return ret;\n    },\n\n    visitShapeRef: function (reference) {\n      if (typeof reference !== \"string\") {\n        let ex = Exception(\"visitShapeRef expected a string, not \" + JSON.stringify(reference));\n        console.warn(ex);\n        throw ex;\n      }\n      return reference;\n    },\n\n    visitShapeExternal: function (expr) {\n      this._testUnknownAttributes(expr, [\"id\"], \"ShapeExternal\", this.visitShapeNot)\n      return Object.assign(\"id\" in expr ? { id: expr.id } : {}, { type: \"ShapeExternal\" });\n    },\n\n    // _visitGroup: visit a grouping expression (someOf or eachOf)\n    _visitGroup: function (expr, type) {\n      var _Visitor = this;\n      var r = Object.assign(\n        // pre-declare an id so it sorts to the top\n        \"id\" in expr ? { id: null } : { },\n        { type: expr.type }\n      );\n      r.expressions = expr.expressions.map(function (nested) {\n        return _Visitor.visitExpression(nested);\n      });\n      return this._maybeSet(expr, r, \"expr\",\n                            [\"id\", \"min\", \"max\", \"annotations\", \"semActs\"], [\"expressions\"]);\n    },\n\n    visitTripleConstraint: function (expr) {\n      return this._maybeSet(expr,\n                            Object.assign(\n                              // pre-declare an id so it sorts to the top\n                              \"id\" in expr ? { id: null } : { },\n                              { type: \"TripleConstraint\" }\n                            ),\n                            \"TripleConstraint\",\n                            [\"id\", \"inverse\", \"predicate\", \"valueExpr\",\n                             \"min\", \"max\", \"annotations\", \"semActs\"])\n    },\n\n    visitExpression: function (expr) {\n      if (typeof expr === \"string\")\n        return this.visitInclusion(expr);\n      var r = expr.type === \"TripleConstraint\" ? this.visitTripleConstraint(expr) :\n          expr.type === \"OneOf\" ? this.visitOneOf(expr) :\n          expr.type === \"EachOf\" ? this.visitEachOf(expr) :\n          null;\n      if (r === null)\n        throw Error(\"unexpected expression type: \" + expr.type);\n      else\n        return r;\n    },\n\n    visitValues: function (values) {\n      var _Visitor = this;\n      return values.map(function (t) {\n        return isTerm(t) || t.type === \"Language\" ?\n          t :\n          _Visitor.visitStemRange(t);\n      });\n    },\n\n    visitStemRange: function (t) {\n      var _Visitor = this; // console.log(Error(t.type).stack);\n      // _expect(t, \"type\", \"IriStemRange\");\n      if (!(\"type\" in t))\n        _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(t)+\" to have a 'type' attribute.\"));\n      var stemRangeTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n      if (stemRangeTypes.indexOf(t.type) === -1)\n        _Visitor.runtimeError(Error(\"expected type attribute '\"+t.type+\"' to be in '\"+stemRangeTypes+\"'.\"));\n      var stem;\n      if (isTerm(t)) {\n        _expect(t.stem, \"type\", \"Wildcard\");\n        stem = { type: t.type, stem: { type: \"Wildcard\" } };\n      } else {\n        stem = { type: t.type, stem: t.stem };\n      }\n      if (t.exclusions) {\n        stem.exclusions = t.exclusions.map(function (c) {\n          return _Visitor.visitExclusion(c);\n        });\n      }\n      return stem;\n    },\n\n    visitExclusion: function (c) {\n      if (!isTerm(c)) {\n        // _expect(c, \"type\", \"IriStem\");\n        if (!(\"type\" in c))\n          _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\"));\n        var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n        if (stemTypes.indexOf(c.type) === -1)\n          _Visitor.runtimeError(Error(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\"));\n        return { type: c.type, stem: c.stem };\n      } else {\n        return c;\n      }\n    },\n\n    visitInclusion: function (inclusion) {\n      if (typeof inclusion !== \"string\") {\n        let ex = Exception(\"visitInclusion expected a string, not \" + JSON.stringify(inclusion));\n        console.warn(ex);\n        throw ex;\n      }\n      return inclusion;\n    },\n\n    _maybeSet: function (obj, ret, context, members, ignore) {\n      var _Visitor = this;\n      this._testUnknownAttributes(obj, ignore ? members.concat(ignore) : members, context, this._maybeSet)\n      members.forEach(function (member) {\n        var methodName = \"visit\" + member.charAt(0).toUpperCase() + member.slice(1);\n        if (member in obj) {\n          var f = _Visitor[methodName];\n          if (typeof f !== \"function\") {\n            throw Error(methodName + \" not found in Visitor\");\n          }\n          var t = f.call(_Visitor, obj[member]);\n          if (t !== undefined) {\n            ret[member] = t;\n          }\n        }\n      });\n      return ret;\n    },\n    _visitValue: function (v) {\n      return v;\n    },\n    _visitList: function (l) {\n      return l.slice();\n    },\n    _testUnknownAttributes: function (obj, expected, context, captureFrame) {\n      var unknownMembers = Object.keys(obj).reduce(function (ret, k) {\n        return k !== \"type\" && expected.indexOf(k) === -1 ? ret.concat(k) : ret;\n      }, []);\n      if (unknownMembers.length > 0) {\n        var e = Error(\"unknown propert\" + (unknownMembers.length > 1 ? \"ies\" : \"y\") + \": \" +\n                      unknownMembers.map(function (p) {\n                        return \"\\\"\" + p + \"\\\"\";\n                      }).join(\",\") +\n                      \" in \" + context + \": \" + JSON.stringify(obj));\n        Error.captureStackTrace(e, captureFrame);\n        throw e;\n      }\n    }\n\n  };\n  r.visitBase = r.visitStart = r.visitVirtual = r.visitClosed = r[\"visit@context\"] = r._visitValue;\n  r.visitInherit = r.visitExtra = r.visitAnnotations = r._visitList;\n  r.visitInverse = r.visitPredicate = r._visitValue;\n  r.visitName = r.visitId = r.visitCode = r.visitMin = r.visitMax = r._visitValue;\n\n  r.visitType = r.visitNodeKind = r.visitDatatype = r.visitPattern = r.visitFlags = r.visitLength = r.visitMinlength = r.visitMaxlength = r.visitMininclusive = r.visitMinexclusive = r.visitMaxinclusive = r.visitMaxexclusive = r.visitTotaldigits = r.visitFractiondigits = r._visitValue;\n  r.visitOneOf = r.visitEachOf = r._visitGroup;\n  r.visitShapeAnd = r.visitShapeOr = r._visitShapeGroup;\n  r.visitInclude = r._visitValue;\n  r.visitValueExpr = r.visitShapeExpr;\n  return r;\n\n  // Expect property p with value v in object o\n  function _expect (o, p, v) {\n    if (!(p in o))\n      this._error(\"expected \"+JSON.stringify(o)+\" to have a .\"+p);\n    if (arguments.length > 2 && o[p] !== v)\n      this._error(\"expected \"+o[o]+\" to equal .\"+v);\n  }\n\n  function _error (str) {\n    throw new Error(str);\n  }\n}\n\n// The ShEx Vistor is here to minimize deps for ShExValidator.\n/** create indexes for schema\n */\nShExVisitor.index = function (schema) {\n  let index = {\n    shapeExprs: {},\n    tripleExprs: {}\n  };\n  let v = ShExVisitor();\n\n  let oldVisitExpression = v.visitExpression;\n  v.visitExpression = function (expression) {\n    if (typeof expression === \"object\" && \"id\" in expression)\n      index.tripleExprs[expression.id] = expression;\n    return oldVisitExpression.call(v, expression);\n  };\n\n  let oldVisitShapeExpr = v.visitShapeExpr;\n  v.visitShapeExpr = v.visitValueExpr = function (shapeExpr, label) {\n    if (typeof shapeExpr === \"object\" && \"id\" in shapeExpr)\n      index.shapeExprs[shapeExpr.id] = shapeExpr;\n    return oldVisitShapeExpr.call(v, shapeExpr, label);\n  };\n\n  v.visitSchema(schema);\n  return index;\n}\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExVisitor;\n\n"
        },
        {
          "id": 5,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "index": 5,
          "index2": 3,
          "size": 15295,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/eval-threaded-nerr",
              "loc": "245:48-85"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "var EvalThreadedNErr = (function () {\nvar RdfTerm = require(\"@shexjs/term\");\nvar UNBOUNDED = -1;\n\nfunction vpEngine (schema, shape, index) {\n    var outerExpression = shape.expression;\n    return {\n      match:match\n    };\n\n    function match (graph, node, constraintList, constraintToTripleMapping, tripleToConstraintMapping, neighborhood, recurse, direct, semActHandler, checkValueExpr, trace) {\n\n      /*\n       * returns: list of passing or failing threads (no heterogeneous lists)\n       */\n      function validateExpr (expr, thread) {\n        if (typeof expr === \"string\") { // Inclusion\n          var included = index.tripleExprs[expr];\n          return validateExpr(included, thread);\n        }\n\n        var constraintNo = constraintList.indexOf(expr);\n        var min = \"min\" in expr ? expr.min : 1;\n        var max = \"max\" in expr ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n\n        function validateRept (type, val) {\n          var repeated = 0, errOut = false;\n          var newThreads = [thread];\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          for (; repeated < max && !errOut; ++repeated) {\n            var inner = [];\n            for (var t = 0; t < newThreads.length; ++t) {\n              var newt = newThreads[t];\n              var sub = val(newt);\n              if (sub.length > 0 && sub[0].errors.length === 0) {\n                sub.forEach(newThread => {\n                  var solutions =\n                      \"expression\" in newt ? newt.expression.solutions : [];\n                  if (\"solution\" in newThread)\n                    solutions = solutions.concat(newThread.solution);\n                  delete newThread.solution;\n                  newThread.expression = extend({\n                    type: type,\n                    solutions: solutions\n                  }, minmax);\n                });\n              }\n              if (sub.length === 0 /* min:0 */ || sub[0].errors.length > 0)\n                return repeated < min ? sub : newThreads;\n              else\n                inner = inner.concat(sub);\n              // newThreads.expressions.push(sub);\n            }\n            newThreads = inner;\n          }\n          if (newThreads.length > 0 && newThreads[0].errors.length === 0 && \"semActs\" in expr) {\n            var passes = [];\n            var failures = [];\n            newThreads.forEach(newThread => {\n              const semActErrors = semActHandler.dispatchAll(expr.semActs, \"???\", newThread)\n              if (semActErrors.length === 0) {\n                passes.push(newThread)\n              } else {\n                [].push.apply(newThread.errors, semActErrors);\n                failures.push(newThread);\n              }\n            });\n            newThreads = passes.length > 0 ? passes : failures;\n          }\n          return newThreads;\n        }\n\n        if (expr.type === \"TripleConstraint\") {\n          var negated = \"negated\" in expr && expr.negated || max === 0;\n          if (negated)\n            min = max = Infinity;\n          if (thread.avail[constraintNo] === undefined)\n            thread.avail[constraintNo] = constraintToTripleMapping[constraintNo].slice();\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          var taken = thread.avail[constraintNo].splice(0, min);\n          var passed = negated ? taken.length === 0 : taken.length >= min;\n          var ret = [];\n          var matched = thread.matched;\n          if (passed) {\n            do {\n              ret.push({\n                avail: thread.avail.map(a => { // copy parent thread's avail vector\n                  return a.slice();\n                }), // was: extend({}, thread.avail)\n                errors: thread.errors.slice(),\n                matched: matched.concat({\n                  tNos: taken.slice()\n                }),\n                expression: extend(\n                  {\n                    type: \"TripleConstraintSolutions\",\n                    predicate: expr.predicate,\n                    solutions: taken.map(tripleNo =>  {\n                      return { type: \"halfTestedTriple\", tripleNo: tripleNo, constraintNo: constraintNo };\n                    })\n                    // map(triple => {\n                    //   var t = neighborhood[triple];\n                    //   return {\n                    //     type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: t.object\n                    //   }\n                    // })\n                  },\n                  \"valueExpr\" in expr ? { valueExpr: expr.valueExpr } : {},\n                  \"productionLabel\" in expr ? { productionLabel: expr.productionLabel } : {},\n                  minmax)\n              });\n            } while ((function () {\n              if (thread.avail[constraintNo].length > 0 && taken.length < max) {\n                taken.push(thread.avail[constraintNo].shift());\n                return true;\n              } else {\n                return false;\n              }\n            })());\n          } else {\n            var valueExpr = null;\n            if (typeof expr.valueExpr === \"string\") { // ShapeRef\n              valueExpr = expr.valueExpr;\n              if (RdfTerm.isBlank(valueExpr))\n                valueExpr = index.shapeExprs[valueExpr];\n            } else if (expr.valueExpr) {\n              valueExpr = extend({}, expr.valueExpr)\n            }\n            ret.push({\n              avail: thread.avail,\n              errors: thread.errors.concat([\n                extend({\n                  type: negated ? \"NegatedProperty\" : \"MissingProperty\",\n                  property: expr.predicate\n                }, valueExpr ? { valueExpr: valueExpr } : {})\n              ]),\n              matched: matched\n            });\n          }\n\n          return ret;\n        }\n\n        else if (expr.type === \"OneOf\") {\n          return validateRept(\"OneOfSolutions\", (th) => {\n            var accept = null;\n            var matched = [];\n            var failed = [];\n            expr.expressions.forEach(nested => {\n              var thcopy = {\n                avail: th.avail.map(a => { return a.slice(); }),\n                errors: th.errors,\n                matched: th.matched//.slice() ever needed??\n              };\n              var sub = validateExpr(nested, thcopy);\n              if (sub[0].errors.length === 0) {\n                matched = matched.concat(sub);\n                sub.forEach(newThread => {\n                  var expressions =\n                      \"solution\" in thcopy ? thcopy.solution.expressions : [];\n                  if (\"expression\" in newThread) // undefined for no matches on min card:0\n                    expressions = expressions.concat([newThread.expression]);\n                  delete newThread.expression;\n                  newThread.solution = {\n                    type: \"OneOfSolution\",\n                    expressions: expressions\n                  };\n                });\n              } else\n                failed = failed.concat(sub);\n            });\n            return matched.length > 0 ? matched : failed;\n          });\n        }\n\n        else if (expr.type === \"EachOf\") {\n          return validateRept(\"EachOfSolutions\", (th) => {\n            // Iterate through nested expressions, exprThreads starts as [th].\n            return expr.expressions.reduce((exprThreads, nested) => {\n              // Iterate through current thread list composing nextThreads.\n              // Consider e.g.\n              // <S1> { <p1> . | <p2> .; <p3> . } / { <x> <p2> 2; <p3> 3 } (should pass)\n              // <S1> { <p1> .; <p2> . }          / { <s1> <p1> 1 }        (should fail)\n              return exprThreads.reduce((nextThreads, exprThread) => {\n                var sub = validateExpr(nested, exprThread);\n                // Move newThread.expression into a hierarchical solution structure.\n                sub.forEach(newThread => {\n                  if (newThread.errors.length === 0) {\n                    var expressions =\n                        \"solution\" in exprThread ? exprThread.solution.expressions : [];\n                    if (\"expression\" in newThread) // undefined for no matches on min card:0\n                      expressions = expressions.concat([newThread.expression]);\n                    // console.warn(threadMatched(newThread), \" vs \", exprMatched(expressions));\n                    delete newThread.expression;\n                    newThread.solution = {\n                      type: \"EachOfSolution\",\n                      expressions: expressions // exprThread.expression + newThread.expression\n                    };\n                  }\n                });\n                return nextThreads.concat(sub);\n              }, []);\n            }, [th]);\n          });\n        }\n\n        runtimeError(\"unexpected expr type: \" + expr.type);\n      }\n\n      var startingThread = {\n        avail:[],   // triples remaining by constraint number\n        matched:[], // triples matched in this thread\n        errors:[]   // errors encounted\n      };\n      if (!outerExpression)\n        return { }; // vapid match if no expression\n      var ret = validateExpr(outerExpression, startingThread);\n      // console.log(JSON.stringify(ret));\n      // note: don't return if ret.length === 1 because it might fail the unmatchedTriples test.\n      var longerChosen =\n          ret.reduce((ret, elt) => {\n            if (elt.errors.length > 0)\n              return ret;              // early return\n            var unmatchedTriples = {};\n            // Collect triples assigned to some constraint.\n            Object.keys(tripleToConstraintMapping).forEach(k => {\n              if (tripleToConstraintMapping[k] !== undefined)\n                unmatchedTriples[k] = tripleToConstraintMapping[k];\n            });\n            // Removed triples matched in this thread.\n            elt.matched.forEach(m => {\n              m.tNos.forEach(t => {\n                delete unmatchedTriples[t];\n              });\n            });\n            // Remaining triples are unaccounted for.\n            Object.keys(unmatchedTriples).forEach(t => {\n              elt.errors.push({\n                type: \"ExcessTripleViolation\",\n                triple: neighborhood[t],\n                constraint: constraintList[unmatchedTriples[t]]\n              });\n            });\n            return ret !== null ? ret : // keep first solution\n            // Accept thread with no unmatched triples.\n            Object.keys(unmatchedTriples).length > 0 ? null : elt;\n          }, null);\n      return longerChosen !== null ?\n        finish(longerChosen.expression, constraintList,\n               neighborhood, recurse, direct, semActHandler, checkValueExpr) :\n        ret.length > 1 ? {\n          type: \"PossibleErrors\",\n          errors: ret.reduce((all, e) => {\n            return all.concat([e.errors]);\n          }, [])\n        } : ret[0];\n    }\n\n    function finish (fromValidatePoint, constraintList, neighborhood, recurse, direct, semActHandler, checkValueExpr) {\n      function _dive (solns) {\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n        if (solns.type === \"OneOfSolutions\" ||\n            solns.type === \"EachOfSolutions\") {\n          solns.solutions.forEach(s => {\n            s.expressions.forEach(e => {\n              _dive(e);\n            });\n          });\n        } else if (solns.type === \"TripleConstraintSolutions\") {\n          solns.solutions = solns.solutions.map(x => {\n            if (x.type === \"TestedTriple\") // already done\n              return x; // c.f. validation/3circularRef1_pass-open\n            var t = neighborhood[x.tripleNo];\n            var expr = constraintList[x.constraintNo];\n            var ret = {\n              type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)\n            };\n            function diver (focus, shapeLabel, dive) {\n              var sub = dive(focus, shapeLabel);\n              if (\"errors\" in sub) {\n                // console.dir(sub);\n                var err = {\n                  type: \"ReferenceError\", focus: focus,\n                  shape: shapeLabel\n                };\n                if (typeof shapeLabel === \"string\" && RdfTerm.isBlank(shapeLabel))\n                  err.referencedShape = shape;\n                err.errors = sub;\n                return [err];\n              }\n              if ((\"solution\" in sub || \"solutions\" in sub)&& Object.keys(sub.solution || sub.solutions).length !== 0 ||\n                  sub.type === \"Recursion\")\n                ret.referenced = sub; // !!! needs to aggregate errors and solutions\n              return [];\n            }\n            function diveRecurse (focus, shapeLabel) {\n              return diver(focus, shapeLabel, recurse);\n            }\n            function diveDirect (focus, shapeLabel) {\n              return diver(focus, shapeLabel, direct);\n            }\n            var subErrors = \"valueExpr\" in expr ?\n                checkValueExpr(expr.inverse ? t.subject : t.object, expr.valueExpr, diveRecurse, diveDirect) :\n                [];\n            if (subErrors.length === 0 && \"semActs\" in expr)\n              [].push.apply(subErrors, semActHandler.dispatchAll(expr.semActs, t, ret))\n            if (subErrors.length > 0) {\n              fromValidatePoint.errors = fromValidatePoint.errors || [];\n              fromValidatePoint.errors = fromValidatePoint.errors.concat(subErrors);\n            }\n            return ret;\n          });\n        } else {\n          throw Error(\"unexpected expr type in \" + JSON.stringify(solns));\n        }\n      }\n      if (Object.keys(fromValidatePoint).length > 0) // guard against {}\n        _dive(fromValidatePoint);\n      if (\"semActs\" in shape)\n        fromValidatePoint.semActs = shape.semActs;\n      return fromValidatePoint;\n    }\n  }\n\nfunction extend(base) {\n  if (!base) base = {};\n  for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)\n    for (var name in arg)\n      base[name] = arg[name];\n  return base;\n}\n\nreturn {\n  name: \"eval-threaded-nerr\",\n  description: \"emulation of regular expression engine with error permutations\",\n  compile: vpEngine\n};\n})();\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = EvalThreadedNErr;\n"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "module": "",
          "moduleIdentifier": "",
          "moduleName": "",
          "loc": "shex-webapp-webpack",
          "request": "./shex-validator-user.js",
          "reasons": []
        }
      ]
    },
    {
      "id": 1,
      "rendered": true,
      "initial": true,
      "entry": true,
      "size": 92421,
      "names": [
        "shex-webapp-webpack.min"
      ],
      "files": [
        "shex-webapp-webpack.min.js"
      ],
      "hash": "a973bcd060943718e8c0",
      "siblings": [],
      "parents": [],
      "children": [],
      "childrenByOrder": {},
      "modules": [
        {
          "id": 0,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
          "index": 3,
          "index2": 1,
          "size": 10525,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/term",
              "loc": "31:14-37"
            },
            {
              "moduleId": 5,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
              "type": "cjs require",
              "userRequest": "@shexjs/term",
              "loc": "2:14-37"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "/**\n *\n * isIRI, isBlank, getLiteralType, getLiteralValue\n */\n\nvar ShExTerm = (function () {\n\n  var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,\n    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,\n    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;\n\n  const RdfLangString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\";\n  const XsdString = \"http://www.w3.org/2001/XMLSchema#string\";\n\n  // N3.js:lib/N3Parser.js<0.4.5>:576 with\n  //   s/this\\./Parser./g\n  //   s/token/iri/\n  // ### `_resolveIRI` resolves a relative IRI token against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative.\n  function resolveRelativeIRI (base, iri) {\n\n    if (absoluteIRI.test(iri))\n      return iri\n\n    switch (iri[0]) {\n    // An empty relative IRI indicates the base IRI\n    case undefined: return base;\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      let m = base.match(schemeAuthority);\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? m[1] : m[0]) + _removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default: {\n      return _removeDotSegments(base.replace(/[^\\/?]*(?:\\?.*)?$/, '') + iri);\n    }\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.\n  function _removeDotSegments (iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!dotSegments.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return result + '/' + iri.substr(i + 1);\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  function internalTerm (node) { // !!rdfjsTermToInternal\n    switch (node.termType) {\n    case (\"NamedNode\"):\n      return node.value;\n    case (\"BlankNode\"):\n      return \"_:\" + node.value;\n    case (\"Literal\"):\n      return \"\\\"\" + node.value + \"\\\"\" + (\n        node.datatypeString === RdfLangString\n          ? \"@\" + node.language\n          : node.datatypeString === XsdString\n          ? \"\"\n          : \"^^\" + node.datatypeString\n      );\n    default: throw Error(\"unknown RDFJS node type: \" + JSON.stringify(node))\n    }\n  }\n\n  function internalTriple (triple) { // !!rdfjsTripleToInternal\n    return {\n      subject: internalTerm(triple.subject),\n      predicate: internalTerm(triple.predicate),\n      object: internalTerm(triple.object)\n    };\n  }\n\n  function externalTerm (node, factory) { // !!intermalTermToRdfjs\n    if (isIRI(node)) {\n      return factory.namedNode(node);\n    } else if (isBlank(node)) {\n      return factory.blankNode(node.substr(2));\n    } else if (isLiteral(node)) {\n      let dtOrLang = getLiteralLanguage(node) ||\n          (getLiteralType(node) === XsdString\n           ? null // seems to screw up N3.js\n           : factory.namedNode(getLiteralType(node)))\n      return factory.literal(getLiteralValue(node), dtOrLang)\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  function externalTriple (triple, factory) { // !!rename internalTripleToRdjs\n    return factory.quad(\n      externalTerm(triple.subject, factory),\n      externalTerm(triple.predicate, factory),\n      externalTerm(triple.object, factory)\n    );\n  }\n\n  function intermalTermToTurtle (node, base, prefixes) {\n    if (isIRI(node)) {\n      // if (node === RDF_TYPE) // only valid in Turtle predicates\n      //   return \"a\";\n\n      // Escape special characters\n      if (escape.test(node))\n        node = node.replace(escapeAll, characterReplacer);\n      var pref = Object.keys(prefixes).find(pref => node.startsWith(prefixes[pref]));\n      if (pref) {\n        var rest = node.substr(prefixes[pref].length);\n        if (rest.indexOf(\"\\\\\") === -1) // could also say no more than n of these: [...]\n          return pref + \":\" + rest.replace(/([~!$&'()*+,;=/?#@%])/g, '\\\\' + \"$1\");\n      }\n      if (node.startsWith(base)) {\n        return \"<\" + node.substr(base.length) + \">\";\n      } else {\n        return \"<\" + node + \">\";\n      }\n    } else if (isBlank(node)) {\n      return node;\n    } else if (isLiteral(node)) {\n      var value = getLiteralValue(node);\n      var type = getLiteralType(node);\n      var language = getLiteralLanguage(node);\n      // Escape special characters\n      if (escape.test(value))\n        value = value.replace(escapeAll, characterReplacer);\n      // Write the literal, possibly with type or language\n      if (language)\n        return '\"' + value + '\"@' + language;\n      else if (type)\n        return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);\n      else\n        return '\"' + value + '\"';\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents an IRI in the N3 library\n  function isIRI (entity) {\n    if (typeof entity !== 'string')\n      return false;\n    else if (entity.length === 0)\n      return true;\n    else {\n      var firstChar = entity[0];\n      return firstChar !== '\"' && firstChar !== '_';\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents a literal in the N3 library\n  function isLiteral (entity) {\n    return typeof entity === 'string' && entity[0] === '\"';\n  }\n\n  // Tests whether the given entity (triple object) represents a blank node in the N3 library\n  function isBlank (entity) {\n    return typeof entity === 'string' && entity.substr(0, 2) === '_:';\n  }\n\n  // Tests whether the given entity represents the default graph\n  function isDefaultGraph (entity) {\n    return !entity;\n  }\n\n  // Tests whether the given triple is in the default graph\n  function inDefaultGraph (triple) {\n    return !triple.graph;\n  }\n\n  // Gets the string value of a literal in the N3 library\n  function getLiteralValue (literal) {\n    var match = /^\"([^]*)\"/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1];\n  }\n\n  // Gets the type of a literal in the N3 library\n  function getLiteralType (literal) {\n    var match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^@\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] || (match[2] ? RdfLangString : XsdString);\n  }\n\n  // Gets the language of a literal in the N3 library\n  function getLiteralLanguage (literal) {\n    var match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] ? match[1].toLowerCase() : '';\n  }\n\n\n// rdf:type predicate (for 'a' abbreviation)\nvar RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    RDF_TYPE   = RDF_PREFIX + 'type';\n\n// Characters in literals that require escaping\nvar escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapeReplacements = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n  // Replaces a character by its escaped version\n  function characterReplacer (character) {\n    // Replace a single character by its escaped version\n    var result = escapeReplacements[character];\n    if (result === undefined) {\n      // Replace a single character with its 4-bit unicode escape sequence\n      if (character.length === 1) {\n        result = character.charCodeAt(0).toString(16);\n        result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n      }\n      // Replace a surrogate pair with its 8-bit unicode escape sequence\n      else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                  character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n    }\n    return result;\n  }\n\n  return {\n    RdfLangString: RdfLangString,\n    XsdString: XsdString,\n    resolveRelativeIRI: resolveRelativeIRI,\n    isIRI: isIRI,\n    isLiteral: isLiteral,\n    isBlank: isBlank,\n    isDefaultGraph: isDefaultGraph,\n    inDefaultGraph: inDefaultGraph,\n    getLiteralValue: getLiteralValue,\n    getLiteralType: getLiteralType,\n    getLiteralLanguage: getLiteralLanguage,\n    internalTerm: internalTerm,\n    internalTriple: internalTriple,\n    externalTerm: externalTerm,\n    externalTriple: externalTriple,\n    intermalTermToTurtle: intermalTermToTurtle,\n  }\n})();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExTerm; // node environment\n"
        },
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "index": 0,
          "index2": 5,
          "size": 71,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "issuerPath": null,
          "profile": {
            "factory": 19,
            "building": 9
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": null,
              "moduleIdentifier": null,
              "module": null,
              "moduleName": null,
              "type": "single entry",
              "userRequest": "./shex-validator-user.js",
              "loc": "shex-webapp-webpack"
            },
            {
              "moduleId": null,
              "moduleIdentifier": null,
              "module": null,
              "moduleName": null,
              "type": "single entry",
              "userRequest": "./shex-validator-user.js",
              "loc": "shex-webapp-webpack.min"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 0,
          "source": "const Validator = require('@shexjs/validator')\nconsole.warn(Validator)\n"
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "index": 1,
          "index2": 4,
          "size": 47946,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "issuerId": 1,
          "issuerName": "./shex-validator-user.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            }
          ],
          "profile": {
            "factory": 5,
            "building": 67
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "module": "./shex-validator-user.js",
              "moduleName": "./shex-validator-user.js",
              "type": "cjs require",
              "userRequest": "@shexjs/validator",
              "loc": "1:18-46"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 1,
          "source": "/* ShExValidator - javascript module to validate a graph with respect to Shape Expressions\n *\n * Status: 1/2 tested, no known bugs.\n *\n * TODO:\n *   constraint violation reporting.\n */\n\nvar ShExValidator = (function () {\nvar UNBOUNDED = -1;\n\n// interface constants\nvar Start = { term: \"START\" }\nvar InterfaceOptions = {\n  \"or\": {\n    \"oneOf\": \"exactly one disjunct must pass\",\n    \"someOf\": \"one or more disjuncts must pass\",\n    \"firstOf\": \"disjunct evaluation stops after one passes\"\n  },\n  \"partition\": {\n    \"greedy\": \"each triple constraint consumes all triples matching predicate and object\",\n    \"exhaustive\": \"search all mappings of triples to triple constriant\"\n  }\n};\n\nvar VERBOSE = \"VERBOSE\" in process.env;\n// **ShExValidator** provides ShEx utility functions\n\nvar ProgramFlowError = { type: \"ProgramFlowError\", errors: { type: \"UntrackedError\" } };\n\nvar RdfTerm = require(\"@shexjs/term\");\nlet ShExVisitor = require(\"@shexjs/visitor\");\n\nfunction getLexicalValue (term) {\n  return RdfTerm.isIRI(term) ? term :\n    RdfTerm.isLiteral(term) ? RdfTerm.getLiteralValue(term) :\n    term.substr(2); // bnodes start with \"_:\"\n}\n\n\nvar XSD = \"http://www.w3.org/2001/XMLSchema#\";\nvar integerDatatypes = [\n  XSD + \"integer\",\n  XSD + \"nonPositiveInteger\",\n  XSD + \"negativeInteger\",\n  XSD + \"long\",\n  XSD + \"int\",\n  XSD + \"short\",\n  XSD + \"byte\",\n  XSD + \"nonNegativeInteger\",\n  XSD + \"unsignedLong\",\n  XSD + \"unsignedInt\",\n  XSD + \"unsignedShort\",\n  XSD + \"unsignedByte\",\n  XSD + \"positiveInteger\"\n];\n\nvar decimalDatatypes = [\n  XSD + \"decimal\",\n].concat(integerDatatypes);\n\nvar numericDatatypes = [\n  XSD + \"float\",\n  XSD + \"double\"\n].concat(decimalDatatypes);\n\nvar numericParsers = {};\nnumericParsers[XSD + \"integer\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?[0-9]+$/))) {\n    parseError(\"illegal integer value '\" + label + \"'\");\n  }\n  return parseInt(label);\n};\nnumericParsers[XSD + \"decimal\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?(?:[0-9]*\\.[0-9]+|[0-9]+)$/))) { // XSD has no pattern for decimal?\n    parseError(\"illegal decimal value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nconst DECIMAL_REGEX = /^[+\\-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[eE][+\\-]?[0-9]+)?$/;\nnumericParsers[XSD + \"float\"  ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) { // XSD has no pattern for float?\n    parseError(\"illegal float value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nnumericParsers[XSD + \"double\" ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) {\n    parseError(\"illegal double value '\" + label + \"'\");\n  }\n  return Number(label);\n};\n\ntestRange = function (value, datatype, parseError) {\n  const ranges = {\n    //    integer            -1 0 1 +1 | \"\" -1.0 +1.0 1e0 NaN INF\n    //    decimal            -1 0 1 +1 -1.0 +1.0 | \"\" 1e0 NaN INF\n    //    float              -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    double             -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    nonPositiveInteger -1 0 +0 -0 | 1 +1 1a a1\n    //    negativeInteger    -1 | 0 +0 -0 1\n    //    long               -1 0 1 +1 |\n    //    int                -1 0 1 +1 |\n    //    short              -32768 0 32767 | -32769 32768\n    //    byte               -128 0 127 | \"\" -129 128\n    //    nonNegativeInteger 0 -0 +0 1 +1 | -1\n    //    unsignedLong       0 1 | -1\n    //    unsignedInt        0 1 | -1\n    //    unsignedShort      0 65535 | -1 65536\n    //    unsignedByte       0 255 | -1 256\n    //    positiveInteger    1 | -1 0\n    //    string             \"\" \"a\" \"0\"\n    //    boolean            true false 0 1 | \"\" TRUE FALSE tRuE fAlSe -1 2 10 01\n    //    dateTime           \"2012-01-02T12:34:56.78Z\" | \"\" \"2012-01-02T\" \"2012-01-02\"\n    integer:            { min: -Infinity           , max: Infinity },\n    decimal:            { min: -Infinity           , max: Infinity },\n    float:              { min: -Infinity           , max: Infinity },\n    double:             { min: -Infinity           , max: Infinity },\n    nonPositiveInteger: { min: -Infinity           , max: 0        },\n    negativeInteger:    { min: -Infinity           , max: -1       },\n    long:               { min: -9223372036854775808, max: 9223372036854775807 },\n    int:                { min: -2147483648         , max: 2147483647 },\n    short:              { min: -32768              , max: 32767    },\n    byte:               { min: -128                , max: 127      },\n    nonNegativeInteger: { min: 0                   , max: Infinity },\n    unsignedLong:       { min: 0                   , max: 18446744073709551615 },\n    unsignedInt:        { min: 0                   , max: 4294967295 },\n    unsignedShort:      { min: 0                   , max: 65535    },\n    unsignedByte:       { min: 0                   , max: 255      },\n    positiveInteger:    { min: 1                   , max: Infinity }\n  }\n  var parms = ranges[datatype.substr(XSD.length)];\n  if (!parms) throw Error(\"unexpected datatype: \" + datatype);\n  if (value < parms.min) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is less than the min:\", parms.min);\n  } else if (value > parms.max) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is greater than the max:\", parms.min);\n  }\n};\n\n/*\nfunction intSubType (spec, label, parseError) {\n  var ret = numericParsers[XSD + \"integer\"](label, parseError);\n  if (\"min\" in spec && ret < spec.min)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be < \" + spec.min);\n  if (\"max\" in spec && ret > spec.max)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be > \" + spec.max);\n  return ret;\n}\n[{type: \"nonPositiveInteger\", max: 0},\n {type: \"negativeInteger\", max: -1},\n {type: \"long\", min: -9223372036854775808, max: 9223372036854775807}, // beyond IEEE double\n {type: \"int\", min: -2147483648, max: 2147483647},\n {type: \"short\", min: -32768, max: 32767},\n {type: \"byte\", min: -128, max: 127},\n {type: \"nonNegativeInteger\", min: 0},\n {type: \"unsignedLong\", min: 0, max: 18446744073709551615},\n {type: \"unsignedInt\", min: 0, max: 4294967295},\n {type: \"unsignedShort\", min: 0, max: 65535},\n {type: \"unsignedByte\", min: 0, max: 255},\n {type: \"positiveInteger\", min: 1}].forEach(function (i) {\n   numericParsers[XSD + i.type ] = function (label, parseError) {\n     return intSubType(i, label, parseError);\n   };\n });\n*/\n\nvar stringTests = {\n  length   : function (v, l) { return v.length === l; },\n  minlength: function (v, l) { return v.length  >= l; },\n  maxlength: function (v, l) { return v.length  <= l; }\n};\n\nvar numericValueTests = {\n  mininclusive  : function (n, m) { return n >= m; },\n  minexclusive  : function (n, m) { return n >  m; },\n  maxinclusive  : function (n, m) { return n <= m; },\n  maxexclusive  : function (n, m) { return n <  m; }\n};\n\nvar decimalLexicalTests = {\n  totaldigits   : function (v, d) {\n    var m = v.match(/[0-9]/g);\n    return m && m.length <= d;\n  },\n  fractiondigits: function (v, d) {\n    var m = v.match(/^[+-]?[0-9]*\\.?([0-9]*)$/);\n    return m && m[1].length <= d;\n  }\n};\n\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n/* ShExValidator_constructor - construct an object for validating a schema.\n *\n * schema: a structure produced by a ShEx parser or equivalent.\n * options: object with controls for\n *   lax(true): boolean: whine about missing types in schema.\n *   diagnose(false): boolean: makde validate return a structure with errors.\n */\nfunction ShExValidator_constructor(schema, options) {\n  if (!(this instanceof ShExValidator_constructor))\n    return new ShExValidator_constructor(schema, options);\n  let index = schema._index || ShExVisitor.index(schema)\n  this.type = \"ShExValidator\";\n  options = options || {};\n  this.options = options;\n  this.options.or = this.options.or || \"someOf\";\n  this.options.partition = this.options.partition || \"exhaustive\";\n  if (!(\"noCache\" in options && options.noCache))\n    this.known = {};\n\n  var _ShExValidator = this;\n  this.schema = schema;\n  this._expect = this.options.lax ? noop : expect; // report errors on missing types.\n  this._optimize = {}; // optimizations:\n    // hasRepeatedGroups: whether there are patterns like (:p1 ., :p2 .)*\n  this.reset = function () {  }; // included in case we need it later.\n  // var regexModule = this.options.regexModule || require(\"@shexjs/eval-simple-1err\");\n  var regexModule = this.options.regexModule || require(\"@shexjs/eval-threaded-nerr\");\n\n  /* getAST - compile a traditional regular expression abstract syntax tree.\n   * Tested but not used at present.\n   */\n  this.getAST = function () {\n    return {\n      type: \"AST\",\n      shapes: schema.shapes.reduce(function (ret, shape) {\n        ret[shape.id] = {\n          type: \"ASTshape\",\n          expression: _compileShapeToAST(shape.expression, [], _ShExValidator.schema)\n        };\n        return ret;\n      }, {})\n    };\n  };\n\n  /* indexTripleConstraints - compile regular expression and index triple constraints\n   */\n  this.indexTripleConstraints = function (expression) {\n    // list of triple constraints from (:p1 ., (:p2 . | :p3 .))\n    var tripleConstraints = [];\n\n    if (expression)\n      indexTripleConstraints_dive(expression);\n    return tripleConstraints;\n\n    function indexTripleConstraints_dive (expr) {\n      if (typeof expr === \"string\") // Inclusion\n        indexTripleConstraints_dive(index.tripleExprs[expr]);\n\n      else if (expr.type === \"TripleConstraint\")\n        tripleConstraints.push(expr)-1;\n\n      else if (expr.type === \"OneOf\" || expr.type === \"EachOf\")\n        expr.expressions.forEach(function (nested) {\n          indexTripleConstraints_dive(nested);\n        });\n\n      // @@TODO shape.virtual, shape.inherit\n      else\n        runtimeError(\"unexpected expr type: \" + expr.type);\n    };\n  };\n\n  /* emptyTracker - a tracker that does nothing\n   */\n  this.emptyTracker = function () {\n    var noop = x => x;\n    return {\n      recurse: noop,\n      known: noop,\n      enter: function (point, label) { ++this.depth; },\n      exit: function (point, label, ret) { --this.depth; },\n      depth: 0\n    };\n  };\n\n  /* validate - test point in db against the schema for labelOrShape\n   * depth: level of recurssion; for logging.\n   */\n  this.validate = function (db, point, label, tracker, seen) {\n    // default to schema's start shape\n    if (typeof point === \"object\" && \"termType\" in point) {\n      point = RdfTerm.internalTerm(point)\n    }\n    if (typeof point === \"object\") {\n      var shapeMap = point;\n      if (this.options.results === \"api\") {\n        return shapeMap.map(pair => {\n          var time = new Date();\n          var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n          time = new Date() - time;\n          return {\n            node: pair.node,\n            shape: pair.shape,\n            status: \"errors\" in res ? \"nonconformant\" : \"conformant\",\n            appinfo: res,\n            elapsed: time\n          };\n        });\n      }\n      var results = shapeMap.reduce((ret, pair) => {\n        var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n        return \"errors\" in res ?\n          { passes: ret.passes, failures: ret.failures.concat(res) } :\n          { passes: ret.passes.concat(res), failures: ret.failures } ;\n      }, {passes: [], failures: []});\n      if (false && this.options.results === \"api\") {\n        var ret = {};\n        function _add (n, s, r) {\n          if (!(n in ret)) {\n            ret[n] = [{shape: s, result: r}];\n            return;\n          }\n          if (ret[n].filter(p => { return p.shape === s; }))\n            return;\n          ret[n].push({shape: s, results: r});\n        }\n        results.passes.forEach(p => { _add(p.node, p.shape, true); });\n        results.failures.forEach(p => { _add(p.node, p.shape, false); });\n        return ret;\n      }\n      if (results.failures.length) {\n        return results.failures.length !== 1 ?\n          { type: \"FailureList\", errors: results.failures } :\n          results.failures [0];\n      } else {\n        return results.passes.length !== 1 ?\n          { type: \"SolutionList\", solutions: results.passes } :\n          results.passes [0];\n      }\n    }\n\n    var outside = tracker === undefined;\n    // logging stuff\n    if (!tracker)\n      tracker = this.emptyTracker();\n    if (!label || label === Start) {\n      if (!schema.start)\n        runtimeError(\"start production not defined\");\n    }\n\n    var shape = null;\n    if (label == Start) {\n      shape = schema.start;\n    } else if (!(\"shapes\" in this.schema) || this.schema.shapes.length === 0) {\n      runtimeError(\"shape \" + label + \" not found; no shapes in schema\");\n    } else if (label in index.shapeExprs) {\n      shape = index.shapeExprs[label]\n    } else {\n      runtimeError(\"shape \" + label + \" not found in:\\n\" + Object.keys(index.shapeExprs || []).map(s => \"  \" + s).join(\"\\n\"));\n    }\n\n    if (seen === undefined)\n      seen = {};\n    var seenKey = point + \"@\" + (label === Start ? \"_: -start-\" : label);\n    if (seenKey in seen)\n      return tracker.recurse({\n        type: \"Recursion\",\n        node: ldify(point),\n        shape: label\n      });\n    if (\"known\" in this && seenKey in this.known)\n      return tracker.known(this.known[seenKey]);\n    seen[seenKey] = { point: point, shape: label };\n    tracker.enter(point, label);\n    var ret = this._validateShapeExpr(db, point, shape, label, tracker, seen);\n    tracker.exit(point, label, ret);\n    delete seen[seenKey];\n    if (\"known\" in this)\n      this.known[seenKey] = ret;\n    if (\"startActs\" in schema && outside) {\n      ret.startActs = schema.startActs;\n    }\n    return ret;\n  }\n\n  this._validateShapeExpr = function (db, point, shapeExpr, shapeLabel, tracker, seen) {\n    if (point === \"\")\n      throw Error(\"validation needs a valid focus node\");\n    if (typeof shapeExpr === \"string\") { // ShapeRef\n      return this._validateShapeExpr(db, point, index.shapeExprs[shapeExpr], shapeExpr, tracker, seen);\n    } else if (shapeExpr.type === \"NodeConstraint\") {\n      var errors = this._errorsMatchingNodeConstraint(point, shapeExpr, null);\n      return errors.length ? {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors.map(function (error) {\n          return {\n            type: \"NodeConstraintViolation\",\n            shapeExpr: shapeExpr,\n            error: error\n          };\n        })\n      } : {\n        type: \"NodeTest\",\n        node: ldify(point),\n        shape: shapeLabel,\n        shapeExpr: shapeExpr\n      };\n    } else if (shapeExpr.type === \"Shape\") {\n      return this._validateShape(db, point, regexModule.compile(schema, shapeExpr, index),\n                                 shapeExpr, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeExternal\") {\n      return this.options.validateExtern(db, point, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeOr\") {\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          return { type: \"ShapeOrResults\", solution: sub };\n      }\n      return { type: \"ShapeOrFailure\", errors: errors };\n    } else if (shapeExpr.type === \"ShapeNot\") {\n      var sub = this._validateShapeExpr(db, point, shapeExpr.shapeExpr, shapeLabel, tracker, seen);\n      if (\"errors\" in sub)\n          return { type: \"ShapeNotResults\", solution: sub };\n        else\n          return { type: \"ShapeNotFailure\", errors: sub };\n    } else if (shapeExpr.type === \"ShapeAnd\") {\n      var passes = [];\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          passes.push(sub);\n      }\n      if (errors.length > 0) {\n        return  { type: \"ShapeAndFailure\", errors: errors};\n      }\n      return { type: \"ShapeAndResults\", solutions: passes };\n    } else\n      throw Error(\"expected one of Shape{Ref,And,Or} or NodeConstraint, got \" + JSON.stringify(shapeExpr));\n  }\n\n  this._validateShape = function (db, point, regexEngine, shape, shapeLabel, tracker, seen) {\n    var _ShExValidator = this;\n\n    var ret = null;\n    var startAcionStorage = {}; // !!! need test to see this write to results structure.\n    if (\"startActs\" in schema) {\n      const semActErrors = this.semActHandler.dispatchAll(schema.startActs, null, startAcionStorage)\n      if (semActErrors.length)\n        return {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: semActErrors\n        }; // some semAct aborted !! return real error\n    }\n    // @@ add to tracker: f(\"validating <\" + point + \"> as <\" + shapeLabel + \">\");\n\n    var fromDB  = db.getNeighborhood(point, shapeLabel, shape);\n    var outgoing = indexNeighborhood(fromDB.outgoing.sort(\n      (l, r) => sparqlOrder(l.object, r.object)\n    ));\n    var incoming = indexNeighborhood(fromDB.incoming.sort(\n      (l, r) => sparqlOrder(l.subject, r.subject)\n    ));\n    var outgoingLength = fromDB.outgoing.length;\n    var neighborhood = fromDB.outgoing.concat(fromDB.incoming);\n\n    var constraintList = this.indexTripleConstraints(shape.expression);\n    var tripleList = constraintList.reduce(function (ret, constraint, ord) {\n\n      // subject and object depend on direction of constraint.\n      var searchSubject = constraint.inverse ? null : point;\n      var searchObject = constraint.inverse ? point : null;\n      var index = constraint.inverse ? incoming : outgoing;\n\n      // get triples matching predciate\n      var matchPredicate = index.byPredicate[constraint.predicate] ||\n        []; // empty list when no triple matches that constraint\n\n      function _errorsByShapeLabel (focus, shapeLabel) {\n        var sub = _ShExValidator.validate(db, focus, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      function _errorsByShapeExpr (focus, shapeExpr) {\n        var sub = _ShExValidator._validateShapeExpr(db, focus, shapeExpr, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      // strip to triples matching value constraints (apart from @<someShape>)\n      var matchConstraints = _ShExValidator._triplesMatchingShapeExpr(\n        matchPredicate,\n        constraint.valueExpr,\n        constraint.inverse,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeLabel,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeExpr\n      );\n\n      matchConstraints.hits.forEach(function (t) {\n        ret.constraintList[neighborhood.indexOf(t)].push(ord);\n      });\n      matchConstraints.misses.forEach(function (t) {\n        ret.misses[neighborhood.indexOf(t.triple)] = {constraintNo: ord, errors: t.errors};\n      });\n      return ret;\n    }, { misses: {}, constraintList:_seq(neighborhood.length).map(function () { return []; }) }); // start with [[],[]...]\n\n    // @@ add to tracker: f(\"constraints by triple: \", JSON.stringify(tripleList.constraintList));\n\n    var extras = []; // triples accounted for by EXTRA\n    var misses = tripleList.constraintList.reduce(function (ret, constraints, ord) {\n      if (constraints.length === 0 &&                       // matches no constraints\n          ord < outgoingLength &&                           // not an incoming triple\n          ord in tripleList.misses) {                       // predicate matched some constraint(s)\n        if (shape.extra !== undefined &&\n            shape.extra.indexOf(neighborhood[ord].predicate) !== -1) {\n          extras.push(ord);\n        } else {                                            // not declared extra\n          ret.push({                                        // so it's a missed triple.\n            tripleNo: ord,\n            constraintNo: tripleList.misses[ord].constraintNo,\n            errors: tripleList.misses[ord].errors\n          });\n        }\n      }\n      return ret;\n    }, []);\n\n    var xp = crossProduct(tripleList.constraintList);\n    var partitionErrors = [];\n    while ((misses.length === 0 || this.options.partition !== \"greedy\") && xp.next() && ret === null) {\n      // caution: early continues\n\n      var usedTriples = []; // [{s1,p1,o1},{s2,p2,o2}] implicated triples -- used for messages\n      var constraintMatchCount = // [2,1,0,1] how many triples matched a constraint\n        _seq(neighborhood.length).map(function () { return 0; });\n      var tripleToConstraintMapping = xp.get(); // [0,1,0,3] mapping from triple to constraint\n\n      // Triples not mapped to triple constraints are not allowed in closed shapes.\n      if (shape.closed) {\n        var unexpectedTriples = neighborhood.slice(0, outgoingLength).filter((t, i) => {\n          return tripleToConstraintMapping[i] === undefined && // didn't match a constraint\n          extras.indexOf(i) === -1; // wasn't in EXTRAs.\n        });\n        if (unexpectedTriples.length > 0) {\n          partitionErrors.push({\n            errors: [\n              {\n                type: \"ClosedShapeViolation\",\n                unexpectedTriples: unexpectedTriples\n              }\n            ]\n          });\n          continue; // closed shape violation.\n        }\n      }\n\n      // Set usedTriples and constraintMatchCount.\n      tripleToConstraintMapping.forEach(function (tpNumber, ord) {\n        if (tpNumber !== undefined) {\n          usedTriples.push(neighborhood[ord]);\n          ++constraintMatchCount[tpNumber];\n        }\n      });\n\n      // Pivot to triples by constraint.\n      function _constraintToTriples () {\n        var cll = constraintList.length;\n        return tripleToConstraintMapping.slice().\n          reduce(function (ret, c, ord) {\n            if (c !== undefined)\n              ret[c].push(ord);\n            return ret;\n          }, _seq(cll).map(function () { return []; }));\n      }\n\n      tripleToConstraintMapping.slice().sort(function (a,b) { return a-b; }).filter(function (i) { // sort constraint numbers\n        return i !== undefined;\n      }).map(function (n) { return n + \" \"; }).join(\"\"); // e.g. 0 0 1 3\n\n      function _recurse (point, shapeLabel) {\n        return _ShExValidator.validate(db, point, shapeLabel, tracker, seen);\n      }\n      function _direct (point, shapeExpr) {\n        return _ShExValidator._validateShapeExpr(db, point, shapeExpr, shapeLabel, tracker, seen);\n      }\n      function _testExpr (term, valueExpr, recurse, direct) {\n        return _ShExValidator._errorsMatchingShapeExpr(term, valueExpr, recurse, direct)\n      }\n      var results = regexEngine.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, _direct, this.semActHandler, _testExpr, null);\n      // {// testing parity between two engines\n      //   var nfa = require(\"@shexjs/eval-simple-1err\").compile(schema, shape);\n      //   var fromNFA = nfa.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, this.semActHandler, _testExpr, null);\n      //   if (\"errors\" in fromNFA !== \"errors\" in results)\n      //     { throw Error(JSON.stringify(results) + \" vs \" + JSON.stringify(fromNFA)); }\n      // }\n      if (\"errors\" in results) {\n        partitionErrors.push({\n          errors: results.errors\n        });\n        if (_ShExValidator.options.partition !== \"exhaustive\")\n          break;\n        else\n          continue;\n      }\n\n      // @@ add to tracker: f(\"post-regexp \" + usedTriples.join(\" \"));\n\n      var possibleRet = { type: \"ShapeTest\", node: ldify(point), shape: shapeLabel };\n      if (Object.keys(results).length > 0) // only include .solution for non-empty pattern\n        possibleRet.solution = results;\n      if (\"semActs\" in shape) {\n        const semActErrors = this.semActHandler.dispatchAll(shape.semActs, results, possibleRet)\n        if (semActErrors.length) {\n          // some semAct aborted\n          partitionErrors.push({\n            errors: semActErrors\n          });\n          if (_ShExValidator.options.partition !== \"exhaustive\")\n            break;\n          else\n            continue;\n        }\n      }\n      // @@ add to tracker: f(\"final \" + usedTriples.join(\" \"));\n\n      ret = possibleRet;\n      partitionErrors = [];\n      // alts.push(tripleToConstraintMapping);\n    }\n    var missErrors = misses.map(function (miss) {\n      var t = neighborhood[miss.tripleNo];\n      return {\n        type: \"TypeMismatch\",\n        triple: {type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)},\n        constraint: constraintList[miss.constraintNo],\n        errors: miss.errors\n      };\n    });\n    let errors = missErrors.concat(partitionErrors.length === 1 ? partitionErrors[0].errors : partitionErrors);\n    if (errors.length > 0) {\n      ret = {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors\n      };\n    }\n\n    if (VERBOSE) { // remove N3jsTripleToString\n      neighborhood.forEach(function (t) {\n        delete t.toString;\n      });\n    }\n    // @@ add to tracker: f(\"</\" + shapeLabel + \">\");\n    return addShapeAttributes(ret);\n\n    function addShapeAttributes (ret) {\n      if (\"annotations\" in shape)\n        ret.annotations = shape.annotations;\n      return ret;\n    }\n  };\n\n  this._triplesMatchingShapeExpr = function (triples, valueExpr, inverse, recurse, direct) {\n    var _ShExValidator = this;\n    var misses = [];\n    var hits = [];\n    triples.forEach(function (triple) {\n      var value = inverse ? triple.subject : triple.object;\n      var errors = valueExpr === undefined ?\n          [] :\n          _ShExValidator._errorsMatchingShapeExpr(value, valueExpr, recurse, direct);\n      if (errors.length === 0) {\n        hits.push(triple);\n      } else if (hits.indexOf(triple) === -1) {\n        misses.push({triple: triple, errors: errors});\n      }\n    });\n    return { hits: hits, misses: misses };\n  }\n  this._errorsMatchingShapeExpr = function (value, valueExpr, recurse, direct) {\n    var _ShExValidator = this;\n    if (typeof valueExpr === \"string\") { // ShapeRef\n      return recurse ? recurse(value, valueExpr) : [];\n    } else if (valueExpr.type === \"NodeConstraint\") {\n      return this._errorsMatchingNodeConstraint(value, valueExpr, null);\n    } else if (valueExpr.type === \"Shape\") {\n      return direct === undefined ? [] : direct(value, valueExpr);\n    } else if (valueExpr.type === \"ShapeOr\") {\n      var ret = [];\n      for (var i = 0; i < valueExpr.shapeExprs.length; ++i) {\n        var nested = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExprs[i], recurse, direct);\n        if (nested.length === 0)\n          return nested;\n        ret = ret.concat(nested);\n      }\n      return ret;\n    } else if (valueExpr.type === \"ShapeAnd\") {\n      return valueExpr.shapeExprs.reduce(function (ret, nested, iter) {\n        return ret.concat(_ShExValidator._errorsMatchingShapeExpr(value, nested, recurse, direct, true));\n      }, []);\n    } else if (valueExpr.type === \"ShapeNot\") {\n      var ret = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExpr, recurse, direct, true);\n      return ret.length ?\n        [] :\n        [\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": expected NOT to pass\"];\n    } else {\n      throw Error(\"unknown value expression type '\" + valueExpr.type + \"'\");\n    }\n  };\n\n  /* _errorsMatchingNodeConstraint - return whether the value matches the value\n   * expression without checking shape references.\n   */\n  this._errorsMatchingNodeConstraint = function (value, valueExpr, recurse) {\n    var errors = [];\n    var label = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralValue(value) :\n      RdfTerm.isBlank(value) ? value.substring(2) :\n      value;\n    var dt = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralType(value) : null;\n    var numeric = integerDatatypes.indexOf(dt) !== -1 ? XSD + \"integer\" : numericDatatypes.indexOf(dt) !== -1 ? dt : undefined;\n\n    function validationError () {\n      var errorStr = Array.prototype.join.call(arguments, \"\");\n      errors.push(\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": \" + errorStr);\n      return false;\n    }\n    // if (negated) ;\n    if (false) {\n      // wildcard -- ignore\n    } else {\n      if (\"nodeKind\" in valueExpr) {\n        if ([\"iri\", \"bnode\", \"literal\", \"nonliteral\"].indexOf(valueExpr.nodeKind) === -1) {\n          validationError(\"unknown node kind '\" + valueExpr.nodeKind + \"'\");\n        }\n        if (RdfTerm.isBlank(value)) {\n          if (valueExpr.nodeKind === \"iri\" || valueExpr.nodeKind === \"literal\") {\n            validationError(\"blank node found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (RdfTerm.isLiteral(value)) {\n          if (valueExpr.nodeKind !== \"literal\") {\n            validationError(\"literal found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (valueExpr.nodeKind === \"bnode\" || valueExpr.nodeKind === \"literal\") {\n          validationError(\"iri found when \" + valueExpr.nodeKind + \" expected\");\n        }\n      }\n\n      if (valueExpr.datatype  && valueExpr.values  ) validationError(\"found both datatype and values in \"   +tripleConstraint);\n\n      if (valueExpr.datatype) {\n        if (!RdfTerm.isLiteral(value)) {\n          validationError(\"mismatched datatype: \" + value + \" is not a literal with datatype \" + valueExpr.datatype);\n        }\n        else if (RdfTerm.getLiteralType(value) !== valueExpr.datatype) {\n          validationError(\"mismatched datatype: \" + RdfTerm.getLiteralType(value) + \" !== \" + valueExpr.datatype);\n        }\n        else if (numeric) {\n          testRange(numericParsers[numeric](label, validationError), valueExpr.datatype, validationError);\n        }\n        else if (valueExpr.datatype === XSD + \"boolean\") {\n          if (label !== \"true\" && label !== \"false\" && label !== \"1\" && label !== \"0\")\n            validationError(\"illegal boolean value: \" + label);\n        }\n        else if (valueExpr.datatype === XSD + \"dateTime\") {\n          if (!label.match(/^[+-]?\\d{4}-[01]\\d-[0-3]\\dT[0-5]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?([+-][0-2]\\d:[0-5]\\d|Z)?$/))\n            validationError(\"illegal dateTime value: \" + label);\n        }\n      }\n\n      if (valueExpr.values) {\n        if (RdfTerm.isLiteral(value) && valueExpr.values.reduce((ret, v) => {\n          if (ret) return true;\n          var ld = ldify(value);\n          if (v.type === \"Language\") {\n            return v.languageTag === ld.language; // @@ use equals/normalizeTest\n          }\n          if (!(typeof v === \"object\" && \"value\" in v))\n            return false;\n          return v.value === ld.value &&\n            v.type === ld.type &&\n            v.language === ld.language;\n        }, false)) {\n          // literal match\n        } else if (valueExpr.values.indexOf(value) !== -1) {\n          // trivial match\n        } else {\n          if (!(valueExpr.values.some(function (valueConstraint) {\n            if (typeof valueConstraint === \"object\" && !(\"value\" in valueConstraint)) { // isTerm me -- strike \"value\" in\n              if (!(\"type\" in valueConstraint))\n                runtimeError(\"expected \"+JSON.stringify(valueConstraint)+\" to have a 'type' attribute.\");\n              var stemRangeTypes = [\n                \"Language\",\n                \"IriStem\",      \"LiteralStem\",      \"LanguageStem\",\n                \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"\n              ];\n              if (stemRangeTypes.indexOf(valueConstraint.type) === -1)\n                runtimeError(\"expected type attribute '\"+valueConstraint.type+\"' to be in '\"+stemRangeTypes+\"'.\");\n\n              /* expect N3.js literals with {Literal,Language}StemRange\n               *       or non-literals with IriStemRange\n               */\n              function normalizedTest (val, ref, func) {\n                if (RdfTerm.isLiteral(val)) {\n                  if ([\"LiteralStem\", \"LiteralStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralValue(val), ref);\n                  } else if ([\"LanguageStem\", \"LanguageStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralLanguage(val) || null, ref);\n                  } else {\n                    return validationError(\"literal \" + val + \" not comparable with non-literal \" + ref);\n                  }\n                } else {\n                  if ([\"IriStem\", \"IriStemRange\"].indexOf(valueConstraint.type) === -1) {\n                    return validationError(\"nonliteral \" + val + \" not comparable with literal \" + JSON.stringify(ref));\n                  } else {\n                    return func(val, ref);\n                  }\n                }\n              }\n              function startsWith (val, ref) {\n                return normalizedTest(val, ref, (l, r) => {\n                  return (valueConstraint.type === \"LanguageStem\" ||\n                          valueConstraint.type === \"LanguageStemRange\") ?\n                    // rfc4647 basic filtering\n                    l !== null && (l === r || r === \"\" || l[r.length] === \"-\") :\n                    // simple substring\n                    l.startsWith(r);\n                });\n              }\n              function equals (val, ref) {\n                return normalizedTest(val, ref, (l, r) => { return l === r; });\n              }\n\n              if (!isTerm(valueConstraint.stem)) {\n                expect(valueConstraint.stem, \"type\", \"Wildcard\");\n                // match whatever but check exclusions below\n              } else {\n                if (!(startsWith(value, valueConstraint.stem))) {\n                  return false;\n                }\n              }\n              if (valueConstraint.exclusions) {\n                return !valueConstraint.exclusions.some(function (c) {\n                  if (!isTerm(c)) {\n                    if (!(\"type\" in c))\n                      runtimeError(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\");\n                    var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n                    if (stemTypes.indexOf(c.type) === -1)\n                      runtimeError(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\");\n                    return startsWith(value, c.stem);\n                  } else {\n                    return equals(value, c);\n                  }\n                });\n              }\n              return true;\n            } else {\n              // ignore -- would have caught it above\n            }\n          }))) {\n            validationError(\"value \" + value + \" not found in set \" + JSON.stringify(valueExpr.values));\n          }\n        }\n      }\n    }\n\n    if (\"pattern\" in valueExpr) {\n      var regexp = \"flags\" in valueExpr ?\n\t  new RegExp(valueExpr.pattern, valueExpr.flags) :\n\t  new RegExp(valueExpr.pattern);\n      if (!(getLexicalValue(value).match(regexp)))\n        validationError(\"value \" + getLexicalValue(value) + \" did not match pattern \" + valueExpr.pattern);\n    }\n\n    Object.keys(stringTests).forEach(function (test) {\n      if (test in valueExpr && !stringTests[test](label, valueExpr[test])) {\n        validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n      }\n    });\n\n    Object.keys(numericValueTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric) {\n          if (!numericValueTests[test](numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n\n    Object.keys(decimalLexicalTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric === XSD + \"integer\" || numeric === XSD + \"decimal\") {\n          if (!decimalLexicalTests[test](\"\"+numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n    return errors;\n  };\n\n  this.semActHandler = {\n    handlers: { },\n    results: { },\n    /**\n     * Store a semantic action handler.\n     *\n     * @param {string} name - semantic action's URL.\n     * @param {object} handler - handler function.\n     *\n     * The handler object has a dispatch function is invoked with:\n     * @param {string} code - text of the semantic action.\n     * @param {object} ctx - matched triple or results subset.\n     * @param {object} extensionStorage - place where the extension writes into the result structure.\n     * @return {bool} false if the extension failed or did not accept the ctx object.\n     */\n    register: function (name, handler) {\n      this.handlers[name] = handler;\n    },\n    /**\n     * Calls all semantic actions, allowing each to write to resultsArtifact.\n     *\n     * @param {array} semActs - list of semantic actions to invoke.\n     * @return {bool} false if any result was false.\n     */\n    dispatchAll: function (semActs, ctx, resultsArtifact) {\n      var _semActHanlder = this;\n      return semActs.reduce(function (ret, semAct) {\n        if (ret.length === 0 && semAct.name in _semActHanlder.handlers) {\n          var code = \"code\" in semAct ? semAct.code : _ShExValidator.options.semActs[semAct.name];\n          var existing = \"extensions\" in resultsArtifact && semAct.name in resultsArtifact.extensions;\n          var extensionStorage = existing ? resultsArtifact.extensions[semAct.name] : {};\n          const response = _semActHanlder.handlers[semAct.name].dispatch(code, ctx, extensionStorage); debugger\n          if (typeof response === 'boolean') {\n            if (!response)\n              ret.push({ type: \"SemActFailure\", errors: [{ type: \"BooleanSemActFailure\", code: code, ctx }] })\n          } else if (typeof response === 'object' && response.constructor === Array) {\n            if (response.length > 0)\n              ret.push({ type: \"SemActFailure\", errors: response })\n          } else {\n            throw Error(\"unsupported response from semantic action handler: \" + JSON.stringify(response))\n          }\n          if (!existing && Object.keys(extensionStorage).length > 0) {\n            if (!(\"extensions\" in resultsArtifact))\n              resultsArtifact.extensions = {};\n            resultsArtifact.extensions[semAct.name] = extensionStorage;\n          }\n          return ret;\n        }\n        return ret;\n      }, []);\n    }\n  };\n}\n\n/* _compileShapeToAST - compile a shape expression to an abstract syntax tree.\n *\n * currently tested but not used.\n */\nfunction _compileShapeToAST (expression, tripleConstraints, schema) {\n\n  function Epsilon () {\n    this.type = \"Epsilon\";\n  }\n\n  function TripleConstraint (ordinal, predicate, inverse, negated, valueExpr) {\n    this.type = \"TripleConstraint\";\n    // this.ordinal = ordinal; @@ does 1card25\n    this.inverse = !!inverse;\n    this.negated = !!negated;\n    this.predicate = predicate;\n    if (valueExpr !== undefined)\n      this.valueExpr = valueExpr;\n  }\n\n  function Choice (disjuncts) {\n    this.type = \"Choice\";\n    this.disjuncts = disjuncts;\n  }\n\n  function EachOf (conjuncts) {\n    this.type = \"EachOf\";\n    this.conjuncts = conjuncts;\n  }\n\n  function SemActs (expression, semActs) {\n    this.type = \"SemActs\";\n    this.expression = expression;\n    this.semActs = semActs;\n  }\n\n  function KleeneStar (expression) {\n    this.type = \"KleeneStar\";\n    this.expression = expression;\n  }\n\n  function _compileExpression (expr, schema) {\n    var repeated, container;\n\n    /* _repeat: map expr with a min and max cardinality to a corresponding AST with Groups and Stars.\n       expr 1 1 => expr\n       expr 0 1 => Choice(expr, Eps)\n       expr 0 3 => Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps)\n       expr 2 5 => EachOf(expr, expr, Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps))\n       expr 0 * => KleeneStar(expr)\n       expr 1 * => EachOf(expr, KleeneStar(expr))\n       expr 2 * => EachOf(expr, expr, KleeneStar(expr))\n\n       @@TODO: favor Plus over Star if Epsilon not in expr.\n    */\n    function _repeat (expr, min, max) {\n      if (min === undefined) { min = 1; }\n      if (max === undefined) { max = 1; }\n\n      if (min === 1 && max === 1) { return expr; }\n\n      var opts = max === UNBOUNDED ?\n        new KleeneStar(expr) :\n        _seq(max - min).reduce(function (ret, elt, ord) {\n          return ord === 0 ?\n            new Choice([expr, new Epsilon]) :\n            new Choice([new EachOf([expr, ret]), new Epsilon]);\n        }, undefined);\n\n      var reqd = min !== 0 ?\n        new EachOf(_seq(min).map(function (ret) {\n          return expr; // @@ something with ret\n        }).concat(opts)) : opts;\n      return reqd;\n    }\n\n    if (typeof expr === \"string\") { // Inclusion\n      var included = schema._index.tripleExprs[expr].expression;\n      return _compileExpression(included, schema);\n    }\n\n    else if (expr.type === \"TripleConstraint\") {\n      // predicate, inverse, negated, valueExpr, annotations, semActs, min, max\n      var valueExpr = \"valueExprRef\" in expr ?\n        schema.valueExprDefns[expr.valueExprRef] :\n        expr.valueExpr;\n      var ordinal = tripleConstraints.push(expr)-1;\n      var tp = new TripleConstraint(ordinal, expr.predicate, expr.inverse, expr.negated, valueExpr);\n      repeated = _repeat(tp, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"OneOf\") {\n      container = new Choice(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"EachOf\") {\n      container = new EachOf(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else throw Error(\"unexpected expr type: \" + expr.type);\n  }\n\n  return expression ? _compileExpression(expression, schema) : new Epsilon();\n}\n\n// http://stackoverflow.com/questions/9422386/lazy-cartesian-product-of-arrays-arbitrary-nested-loops\nfunction crossProduct(sets) {\n  var n = sets.length, carets = [], args = null;\n\n  function init() {\n    args = [];\n    for (var i = 0; i < n; i++) {\n      carets[i] = 0;\n      args[i] = sets[i][0];\n    }\n  }\n\n  function next() {\n\n    // special case: crossProduct([]).next().next() returns false.\n    if (args !== null && args.length === 0)\n      return false;\n\n    if (args === null) {\n      init();\n      return true;\n    }\n    var i = n - 1;\n    carets[i]++;\n    if (carets[i] < sets[i].length) {\n      args[i] = sets[i][carets[i]];\n      return true;\n    }\n    while (carets[i] >= sets[i].length) {\n      if (i == 0) {\n        return false;\n      }\n      carets[i] = 0;\n      args[i] = sets[i][0];\n      carets[--i]++;\n    }\n    args[i] = sets[i][carets[i]];\n    return true;\n  }\n\n  return {\n    next: next,\n    do: function (block, _context) { // old API\n      return block.apply(_context, args);\n    },\n    // new API because\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description\n    // cautions about functions over arguments.\n    get: function () { return args; }\n  };\n}\n\n/* N3jsTripleToString - simple toString function to make N3.js's triples\n * printable.\n */\nvar N3jsTripleToString = function () {\n  function fmt (n) {\n    return RdfTerm.isLiteral(n) ?\n      [ \"http://www.w3.org/2001/XMLSchema#integer\",\n        \"http://www.w3.org/2001/XMLSchema#float\",\n        \"http://www.w3.org/2001/XMLSchema#double\"\n      ].indexOf(RdfTerm.getLiteralType(n)) !== -1 ?\n      parseInt(RdfTerm.getLiteralValue(n)) :\n      n :\n    RdfTerm.isBlank(n) ?\n      n :\n      \"<\" + n + \">\";\n  }\n  return fmt(this.subject) + \" \" + fmt(this.predicate) + \" \" + fmt(this.object) + \" .\";\n};\n\n/* indexNeighborhood - index triples by predicate\n * returns: {\n *     byPredicate: Object: mapping from predicate to triples containing that\n *                  predicate.\n *\n *     candidates: [[1,3], [0,2]]: mapping from triple to the triple constraints\n *                 it matches.  It is initialized to []. Mappings that remain an\n *                 empty set indicate a triple which didn't matching anything in\n *                 the shape.\n *\n *     misses: list to recieve value constraint failures.\n *   }\n */\nfunction indexNeighborhood (triples) {\n  return {\n    byPredicate: triples.reduce(function (ret, t) {\n      var p = t.predicate;\n      if (!(p in ret))\n        ret[p] = [];\n      ret[p].push(t);\n\n      // If in VERBOSE mode, add a nice toString to N3.js's triple objects.\n      if (VERBOSE)\n        t.toString = N3jsTripleToString;\n\n      return ret;\n    }, {}),\n    candidates: _seq(triples.length).map(function () {\n      return [];\n    }),\n    misses: []\n  };\n}\n\n/* sparqlOrder - sort triples by subject following SPARQL partial ordering.\n */\nfunction sparqlOrder (l, r) {\n  var [lprec, rprec] = [l, r].map(\n    x => RdfTerm.isBlank(x) ? 1 : RdfTerm.isLiteral(x) ? 2 : 3\n  );\n  return lprec === rprec ? l.localeCompare(r) : lprec - rprec;\n}\n\n/* Return a list of n \"\"s.\n *\n * Note that Array(n) on its own returns a \"sparse array\" so Array(n).map(f)\n * never calls f.\n */\nfunction _seq (n) {\n  return n === 0 ?\n    [] :\n    Array(n).join(\" \").split(/ /); // hahaha, javascript, you suck.\n}\n\n/* Expect property p with value v in object o\n */\nfunction expect (o, p, v) {\n  if (!(p in o))\n    runtimeError(\"expected \"+JSON.stringify(o)+\" to have a '\"+p+\"' attribute.\");\n  if (arguments.length > 2 && o[p] !== v)\n    runtimeError(\"expected \"+p+\" attribute '\"+o[p]+\"' to equal '\"+v+\"'.\");\n}\n\nfunction noop () {  }\n\nfunction runtimeError () {\n  var errorStr = Array.prototype.join.call(arguments, \"\");\n  var e = new Error(errorStr);\n  Error.captureStackTrace(e, runtimeError);\n  throw e;\n}\n\n  return {\n    construct: ShExValidator_constructor,\n    start: Start,\n    options: InterfaceOptions\n  };\n})();\n\n// Export the `ShExValidator` class as a whole.\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = ShExValidator;\n"
        },
        {
          "id": 3,
          "identifier": "/tmp/npmz/shex-validator-user/node_modules/process/browser.js",
          "name": "./node_modules/process/browser.js",
          "index": 2,
          "index2": 0,
          "size": 5418,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "process",
              "loc": "1:0-84"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"
        },
        {
          "id": 4,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
          "index": 4,
          "index2": 2,
          "size": 13166,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/visitor",
              "loc": "32:18-44"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n  function isShapeRef (expr) {\n    return typeof expr === \"string\" // test for JSON-LD @ID\n  }\n  let isInclusion = isShapeRef;\n\n\nfunction ShExVisitor () {\n  // function expect (l, r) { var ls = JSON.stringify(l), rs = JSON.stringify(r); if (ls !== rs) throw Error(ls+\" !== \"+rs); }\n  var _ShExUtil = this;\n  function visitMap (map, val) {\n    var ret = {};\n    Object.keys(map).forEach(function (item) {\n      ret[item] = val(map[item]);\n    });\n    return ret;\n  }\n  var r = {\n    runtimeError: function (e) {\n      throw e;\n    },\n\n    visitSchema: function (schema) {\n      var ret = { type: \"Schema\" };\n      _expect(schema, \"type\", \"Schema\");\n      this._maybeSet(schema, ret, \"Schema\",\n                     [\"@context\", \"prefixes\", \"base\", \"imports\", \"startActs\", \"start\", \"shapes\"],\n                     [\"_base\", \"_prefixes\", \"_index\", \"_sourceMap\"]\n                    );\n      return ret;\n    },\n\n    visitPrefixes: function (prefixes) {\n      return prefixes === undefined ?\n        undefined :\n        visitMap(prefixes, function (val) {\n          return val;\n        });\n    },\n\n    visitIRI: function (i) {\n      return i;\n    },\n\n    visitImports: function (imports) {\n      var _Visitor = this;\n      return imports.map(function (imp) {\n        return _Visitor.visitIRI(imp);\n      });\n    },\n\n    visitStartActs: function (startActs) {\n      var _Visitor = this;\n      return startActs === undefined ?\n        undefined :\n        startActs.map(function (act) {\n          return _Visitor.visitSemAct(act);\n        });\n    },\n    visitSemActs: function (semActs) {\n      var _Visitor = this;\n      if (semActs === undefined)\n        return undefined;\n      var ret = []\n      Object.keys(semActs).forEach(function (label) {\n        ret.push(_Visitor.visitSemAct(semActs[label], label));\n      });\n      return ret;\n    },\n    visitSemAct: function (semAct, label) {\n      var ret = { type: \"SemAct\" };\n      _expect(semAct, \"type\", \"SemAct\");\n\n      this._maybeSet(semAct, ret, \"SemAct\",\n                     [\"name\", \"code\"]);\n      return ret;\n    },\n\n    visitShapes: function (shapes) {\n      var _Visitor = this;\n      if (shapes === undefined)\n        return undefined;\n      return shapes.map(\n        shapeExpr =>\n          _Visitor.visitShapeExpr(shapeExpr)\n      );\n    },\n\n    visitProductions999: function (productions) { // !! DELETE\n      var _Visitor = this;\n      if (productions === undefined)\n        return undefined;\n      var ret = {}\n      Object.keys(productions).forEach(function (label) {\n        ret[label] = _Visitor.visitExpression(productions[label], label);\n      });\n      return ret;\n    },\n\n    visitShapeExpr: function (expr, label) {\n      if (isShapeRef(expr))\n        return this.visitShapeRef(expr)\n      var r =\n          expr.type === \"Shape\" ? this.visitShape(expr, label) :\n          expr.type === \"NodeConstraint\" ? this.visitNodeConstraint(expr, label) :\n          expr.type === \"ShapeAnd\" ? this.visitShapeAnd(expr, label) :\n          expr.type === \"ShapeOr\" ? this.visitShapeOr(expr, label) :\n          expr.type === \"ShapeNot\" ? this.visitShapeNot(expr, label) :\n          expr.type === \"ShapeExternal\" ? this.visitShapeExternal(expr) :\n          null;// if (expr.type === \"ShapeRef\") r = 0; // console.warn(\"visitShapeExpr:\", r);\n      if (r === null)\n        throw Error(\"unexpected shapeExpr type: \" + expr.type);\n      else\n        return r;\n    },\n\n    // _visitShapeGroup: visit a grouping expression (shapeAnd, shapeOr)\n    _visitShapeGroup: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExprs\"], expr.type, this.visitShapeNot)\n      var _Visitor = this;\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExprs = expr.shapeExprs.map(function (nested) {\n        return _Visitor.visitShapeExpr(nested, label);\n      });\n      return r;\n    },\n\n    // _visitShapeNot: visit negated shape\n    visitShapeNot: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExpr\"], \"ShapeNot\", this.visitShapeNot)\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExpr = this.visitShapeExpr(expr.shapeExpr, label);\n      return r;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitShape: function (shape, label) {\n      var ret = { type: \"Shape\" };\n      _expect(shape, \"type\", \"Shape\");\n\n      this._maybeSet(shape, ret, \"Shape\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"closed\",\n                       \"expression\", \"extra\", \"semActs\", \"annotations\"]);\n      return ret;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitNodeConstraint: function (shape, label) {\n      var ret = { type: \"NodeConstraint\" };\n      _expect(shape, \"type\", \"NodeConstraint\");\n\n      this._maybeSet(shape, ret, \"NodeConstraint\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"nodeKind\", \"datatype\", \"pattern\", \"flags\", \"length\",\n                       \"reference\", \"minlength\", \"maxlength\",\n                       \"mininclusive\", \"minexclusive\", \"maxinclusive\", \"maxexclusive\",\n                       \"totaldigits\", \"fractiondigits\", \"values\", \"annotations\", \"semActs\"]);\n      return ret;\n    },\n\n    visitShapeRef: function (reference) {\n      if (typeof reference !== \"string\") {\n        let ex = Exception(\"visitShapeRef expected a string, not \" + JSON.stringify(reference));\n        console.warn(ex);\n        throw ex;\n      }\n      return reference;\n    },\n\n    visitShapeExternal: function (expr) {\n      this._testUnknownAttributes(expr, [\"id\"], \"ShapeExternal\", this.visitShapeNot)\n      return Object.assign(\"id\" in expr ? { id: expr.id } : {}, { type: \"ShapeExternal\" });\n    },\n\n    // _visitGroup: visit a grouping expression (someOf or eachOf)\n    _visitGroup: function (expr, type) {\n      var _Visitor = this;\n      var r = Object.assign(\n        // pre-declare an id so it sorts to the top\n        \"id\" in expr ? { id: null } : { },\n        { type: expr.type }\n      );\n      r.expressions = expr.expressions.map(function (nested) {\n        return _Visitor.visitExpression(nested);\n      });\n      return this._maybeSet(expr, r, \"expr\",\n                            [\"id\", \"min\", \"max\", \"annotations\", \"semActs\"], [\"expressions\"]);\n    },\n\n    visitTripleConstraint: function (expr) {\n      return this._maybeSet(expr,\n                            Object.assign(\n                              // pre-declare an id so it sorts to the top\n                              \"id\" in expr ? { id: null } : { },\n                              { type: \"TripleConstraint\" }\n                            ),\n                            \"TripleConstraint\",\n                            [\"id\", \"inverse\", \"predicate\", \"valueExpr\",\n                             \"min\", \"max\", \"annotations\", \"semActs\"])\n    },\n\n    visitExpression: function (expr) {\n      if (typeof expr === \"string\")\n        return this.visitInclusion(expr);\n      var r = expr.type === \"TripleConstraint\" ? this.visitTripleConstraint(expr) :\n          expr.type === \"OneOf\" ? this.visitOneOf(expr) :\n          expr.type === \"EachOf\" ? this.visitEachOf(expr) :\n          null;\n      if (r === null)\n        throw Error(\"unexpected expression type: \" + expr.type);\n      else\n        return r;\n    },\n\n    visitValues: function (values) {\n      var _Visitor = this;\n      return values.map(function (t) {\n        return isTerm(t) || t.type === \"Language\" ?\n          t :\n          _Visitor.visitStemRange(t);\n      });\n    },\n\n    visitStemRange: function (t) {\n      var _Visitor = this; // console.log(Error(t.type).stack);\n      // _expect(t, \"type\", \"IriStemRange\");\n      if (!(\"type\" in t))\n        _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(t)+\" to have a 'type' attribute.\"));\n      var stemRangeTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n      if (stemRangeTypes.indexOf(t.type) === -1)\n        _Visitor.runtimeError(Error(\"expected type attribute '\"+t.type+\"' to be in '\"+stemRangeTypes+\"'.\"));\n      var stem;\n      if (isTerm(t)) {\n        _expect(t.stem, \"type\", \"Wildcard\");\n        stem = { type: t.type, stem: { type: \"Wildcard\" } };\n      } else {\n        stem = { type: t.type, stem: t.stem };\n      }\n      if (t.exclusions) {\n        stem.exclusions = t.exclusions.map(function (c) {\n          return _Visitor.visitExclusion(c);\n        });\n      }\n      return stem;\n    },\n\n    visitExclusion: function (c) {\n      if (!isTerm(c)) {\n        // _expect(c, \"type\", \"IriStem\");\n        if (!(\"type\" in c))\n          _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\"));\n        var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n        if (stemTypes.indexOf(c.type) === -1)\n          _Visitor.runtimeError(Error(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\"));\n        return { type: c.type, stem: c.stem };\n      } else {\n        return c;\n      }\n    },\n\n    visitInclusion: function (inclusion) {\n      if (typeof inclusion !== \"string\") {\n        let ex = Exception(\"visitInclusion expected a string, not \" + JSON.stringify(inclusion));\n        console.warn(ex);\n        throw ex;\n      }\n      return inclusion;\n    },\n\n    _maybeSet: function (obj, ret, context, members, ignore) {\n      var _Visitor = this;\n      this._testUnknownAttributes(obj, ignore ? members.concat(ignore) : members, context, this._maybeSet)\n      members.forEach(function (member) {\n        var methodName = \"visit\" + member.charAt(0).toUpperCase() + member.slice(1);\n        if (member in obj) {\n          var f = _Visitor[methodName];\n          if (typeof f !== \"function\") {\n            throw Error(methodName + \" not found in Visitor\");\n          }\n          var t = f.call(_Visitor, obj[member]);\n          if (t !== undefined) {\n            ret[member] = t;\n          }\n        }\n      });\n      return ret;\n    },\n    _visitValue: function (v) {\n      return v;\n    },\n    _visitList: function (l) {\n      return l.slice();\n    },\n    _testUnknownAttributes: function (obj, expected, context, captureFrame) {\n      var unknownMembers = Object.keys(obj).reduce(function (ret, k) {\n        return k !== \"type\" && expected.indexOf(k) === -1 ? ret.concat(k) : ret;\n      }, []);\n      if (unknownMembers.length > 0) {\n        var e = Error(\"unknown propert\" + (unknownMembers.length > 1 ? \"ies\" : \"y\") + \": \" +\n                      unknownMembers.map(function (p) {\n                        return \"\\\"\" + p + \"\\\"\";\n                      }).join(\",\") +\n                      \" in \" + context + \": \" + JSON.stringify(obj));\n        Error.captureStackTrace(e, captureFrame);\n        throw e;\n      }\n    }\n\n  };\n  r.visitBase = r.visitStart = r.visitVirtual = r.visitClosed = r[\"visit@context\"] = r._visitValue;\n  r.visitInherit = r.visitExtra = r.visitAnnotations = r._visitList;\n  r.visitInverse = r.visitPredicate = r._visitValue;\n  r.visitName = r.visitId = r.visitCode = r.visitMin = r.visitMax = r._visitValue;\n\n  r.visitType = r.visitNodeKind = r.visitDatatype = r.visitPattern = r.visitFlags = r.visitLength = r.visitMinlength = r.visitMaxlength = r.visitMininclusive = r.visitMinexclusive = r.visitMaxinclusive = r.visitMaxexclusive = r.visitTotaldigits = r.visitFractiondigits = r._visitValue;\n  r.visitOneOf = r.visitEachOf = r._visitGroup;\n  r.visitShapeAnd = r.visitShapeOr = r._visitShapeGroup;\n  r.visitInclude = r._visitValue;\n  r.visitValueExpr = r.visitShapeExpr;\n  return r;\n\n  // Expect property p with value v in object o\n  function _expect (o, p, v) {\n    if (!(p in o))\n      this._error(\"expected \"+JSON.stringify(o)+\" to have a .\"+p);\n    if (arguments.length > 2 && o[p] !== v)\n      this._error(\"expected \"+o[o]+\" to equal .\"+v);\n  }\n\n  function _error (str) {\n    throw new Error(str);\n  }\n}\n\n// The ShEx Vistor is here to minimize deps for ShExValidator.\n/** create indexes for schema\n */\nShExVisitor.index = function (schema) {\n  let index = {\n    shapeExprs: {},\n    tripleExprs: {}\n  };\n  let v = ShExVisitor();\n\n  let oldVisitExpression = v.visitExpression;\n  v.visitExpression = function (expression) {\n    if (typeof expression === \"object\" && \"id\" in expression)\n      index.tripleExprs[expression.id] = expression;\n    return oldVisitExpression.call(v, expression);\n  };\n\n  let oldVisitShapeExpr = v.visitShapeExpr;\n  v.visitShapeExpr = v.visitValueExpr = function (shapeExpr, label) {\n    if (typeof shapeExpr === \"object\" && \"id\" in shapeExpr)\n      index.shapeExprs[shapeExpr.id] = shapeExpr;\n    return oldVisitShapeExpr.call(v, shapeExpr, label);\n  };\n\n  v.visitSchema(schema);\n  return index;\n}\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExVisitor;\n\n"
        },
        {
          "id": 5,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "index": 5,
          "index2": 3,
          "size": 15295,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0,
            1
          ],
          "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerId": 2,
          "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "issuerPath": [
            {
              "id": 1,
              "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
              "name": "./shex-validator-user.js",
              "profile": {
                "factory": 19,
                "building": 9
              }
            },
            {
              "id": 2,
              "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "profile": {
                "factory": 5,
                "building": 67
              }
            }
          ],
          "profile": {
            "factory": 32,
            "building": 20,
            "dependencies": 23
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "assets": [],
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
              "type": "cjs require",
              "userRequest": "@shexjs/eval-threaded-nerr",
              "loc": "245:48-85"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [
            "ModuleConcatenation bailout: Module is not an ECMAScript module"
          ],
          "depth": 2,
          "source": "var EvalThreadedNErr = (function () {\nvar RdfTerm = require(\"@shexjs/term\");\nvar UNBOUNDED = -1;\n\nfunction vpEngine (schema, shape, index) {\n    var outerExpression = shape.expression;\n    return {\n      match:match\n    };\n\n    function match (graph, node, constraintList, constraintToTripleMapping, tripleToConstraintMapping, neighborhood, recurse, direct, semActHandler, checkValueExpr, trace) {\n\n      /*\n       * returns: list of passing or failing threads (no heterogeneous lists)\n       */\n      function validateExpr (expr, thread) {\n        if (typeof expr === \"string\") { // Inclusion\n          var included = index.tripleExprs[expr];\n          return validateExpr(included, thread);\n        }\n\n        var constraintNo = constraintList.indexOf(expr);\n        var min = \"min\" in expr ? expr.min : 1;\n        var max = \"max\" in expr ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n\n        function validateRept (type, val) {\n          var repeated = 0, errOut = false;\n          var newThreads = [thread];\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          for (; repeated < max && !errOut; ++repeated) {\n            var inner = [];\n            for (var t = 0; t < newThreads.length; ++t) {\n              var newt = newThreads[t];\n              var sub = val(newt);\n              if (sub.length > 0 && sub[0].errors.length === 0) {\n                sub.forEach(newThread => {\n                  var solutions =\n                      \"expression\" in newt ? newt.expression.solutions : [];\n                  if (\"solution\" in newThread)\n                    solutions = solutions.concat(newThread.solution);\n                  delete newThread.solution;\n                  newThread.expression = extend({\n                    type: type,\n                    solutions: solutions\n                  }, minmax);\n                });\n              }\n              if (sub.length === 0 /* min:0 */ || sub[0].errors.length > 0)\n                return repeated < min ? sub : newThreads;\n              else\n                inner = inner.concat(sub);\n              // newThreads.expressions.push(sub);\n            }\n            newThreads = inner;\n          }\n          if (newThreads.length > 0 && newThreads[0].errors.length === 0 && \"semActs\" in expr) {\n            var passes = [];\n            var failures = [];\n            newThreads.forEach(newThread => {\n              const semActErrors = semActHandler.dispatchAll(expr.semActs, \"???\", newThread)\n              if (semActErrors.length === 0) {\n                passes.push(newThread)\n              } else {\n                [].push.apply(newThread.errors, semActErrors);\n                failures.push(newThread);\n              }\n            });\n            newThreads = passes.length > 0 ? passes : failures;\n          }\n          return newThreads;\n        }\n\n        if (expr.type === \"TripleConstraint\") {\n          var negated = \"negated\" in expr && expr.negated || max === 0;\n          if (negated)\n            min = max = Infinity;\n          if (thread.avail[constraintNo] === undefined)\n            thread.avail[constraintNo] = constraintToTripleMapping[constraintNo].slice();\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          var taken = thread.avail[constraintNo].splice(0, min);\n          var passed = negated ? taken.length === 0 : taken.length >= min;\n          var ret = [];\n          var matched = thread.matched;\n          if (passed) {\n            do {\n              ret.push({\n                avail: thread.avail.map(a => { // copy parent thread's avail vector\n                  return a.slice();\n                }), // was: extend({}, thread.avail)\n                errors: thread.errors.slice(),\n                matched: matched.concat({\n                  tNos: taken.slice()\n                }),\n                expression: extend(\n                  {\n                    type: \"TripleConstraintSolutions\",\n                    predicate: expr.predicate,\n                    solutions: taken.map(tripleNo =>  {\n                      return { type: \"halfTestedTriple\", tripleNo: tripleNo, constraintNo: constraintNo };\n                    })\n                    // map(triple => {\n                    //   var t = neighborhood[triple];\n                    //   return {\n                    //     type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: t.object\n                    //   }\n                    // })\n                  },\n                  \"valueExpr\" in expr ? { valueExpr: expr.valueExpr } : {},\n                  \"productionLabel\" in expr ? { productionLabel: expr.productionLabel } : {},\n                  minmax)\n              });\n            } while ((function () {\n              if (thread.avail[constraintNo].length > 0 && taken.length < max) {\n                taken.push(thread.avail[constraintNo].shift());\n                return true;\n              } else {\n                return false;\n              }\n            })());\n          } else {\n            var valueExpr = null;\n            if (typeof expr.valueExpr === \"string\") { // ShapeRef\n              valueExpr = expr.valueExpr;\n              if (RdfTerm.isBlank(valueExpr))\n                valueExpr = index.shapeExprs[valueExpr];\n            } else if (expr.valueExpr) {\n              valueExpr = extend({}, expr.valueExpr)\n            }\n            ret.push({\n              avail: thread.avail,\n              errors: thread.errors.concat([\n                extend({\n                  type: negated ? \"NegatedProperty\" : \"MissingProperty\",\n                  property: expr.predicate\n                }, valueExpr ? { valueExpr: valueExpr } : {})\n              ]),\n              matched: matched\n            });\n          }\n\n          return ret;\n        }\n\n        else if (expr.type === \"OneOf\") {\n          return validateRept(\"OneOfSolutions\", (th) => {\n            var accept = null;\n            var matched = [];\n            var failed = [];\n            expr.expressions.forEach(nested => {\n              var thcopy = {\n                avail: th.avail.map(a => { return a.slice(); }),\n                errors: th.errors,\n                matched: th.matched//.slice() ever needed??\n              };\n              var sub = validateExpr(nested, thcopy);\n              if (sub[0].errors.length === 0) {\n                matched = matched.concat(sub);\n                sub.forEach(newThread => {\n                  var expressions =\n                      \"solution\" in thcopy ? thcopy.solution.expressions : [];\n                  if (\"expression\" in newThread) // undefined for no matches on min card:0\n                    expressions = expressions.concat([newThread.expression]);\n                  delete newThread.expression;\n                  newThread.solution = {\n                    type: \"OneOfSolution\",\n                    expressions: expressions\n                  };\n                });\n              } else\n                failed = failed.concat(sub);\n            });\n            return matched.length > 0 ? matched : failed;\n          });\n        }\n\n        else if (expr.type === \"EachOf\") {\n          return validateRept(\"EachOfSolutions\", (th) => {\n            // Iterate through nested expressions, exprThreads starts as [th].\n            return expr.expressions.reduce((exprThreads, nested) => {\n              // Iterate through current thread list composing nextThreads.\n              // Consider e.g.\n              // <S1> { <p1> . | <p2> .; <p3> . } / { <x> <p2> 2; <p3> 3 } (should pass)\n              // <S1> { <p1> .; <p2> . }          / { <s1> <p1> 1 }        (should fail)\n              return exprThreads.reduce((nextThreads, exprThread) => {\n                var sub = validateExpr(nested, exprThread);\n                // Move newThread.expression into a hierarchical solution structure.\n                sub.forEach(newThread => {\n                  if (newThread.errors.length === 0) {\n                    var expressions =\n                        \"solution\" in exprThread ? exprThread.solution.expressions : [];\n                    if (\"expression\" in newThread) // undefined for no matches on min card:0\n                      expressions = expressions.concat([newThread.expression]);\n                    // console.warn(threadMatched(newThread), \" vs \", exprMatched(expressions));\n                    delete newThread.expression;\n                    newThread.solution = {\n                      type: \"EachOfSolution\",\n                      expressions: expressions // exprThread.expression + newThread.expression\n                    };\n                  }\n                });\n                return nextThreads.concat(sub);\n              }, []);\n            }, [th]);\n          });\n        }\n\n        runtimeError(\"unexpected expr type: \" + expr.type);\n      }\n\n      var startingThread = {\n        avail:[],   // triples remaining by constraint number\n        matched:[], // triples matched in this thread\n        errors:[]   // errors encounted\n      };\n      if (!outerExpression)\n        return { }; // vapid match if no expression\n      var ret = validateExpr(outerExpression, startingThread);\n      // console.log(JSON.stringify(ret));\n      // note: don't return if ret.length === 1 because it might fail the unmatchedTriples test.\n      var longerChosen =\n          ret.reduce((ret, elt) => {\n            if (elt.errors.length > 0)\n              return ret;              // early return\n            var unmatchedTriples = {};\n            // Collect triples assigned to some constraint.\n            Object.keys(tripleToConstraintMapping).forEach(k => {\n              if (tripleToConstraintMapping[k] !== undefined)\n                unmatchedTriples[k] = tripleToConstraintMapping[k];\n            });\n            // Removed triples matched in this thread.\n            elt.matched.forEach(m => {\n              m.tNos.forEach(t => {\n                delete unmatchedTriples[t];\n              });\n            });\n            // Remaining triples are unaccounted for.\n            Object.keys(unmatchedTriples).forEach(t => {\n              elt.errors.push({\n                type: \"ExcessTripleViolation\",\n                triple: neighborhood[t],\n                constraint: constraintList[unmatchedTriples[t]]\n              });\n            });\n            return ret !== null ? ret : // keep first solution\n            // Accept thread with no unmatched triples.\n            Object.keys(unmatchedTriples).length > 0 ? null : elt;\n          }, null);\n      return longerChosen !== null ?\n        finish(longerChosen.expression, constraintList,\n               neighborhood, recurse, direct, semActHandler, checkValueExpr) :\n        ret.length > 1 ? {\n          type: \"PossibleErrors\",\n          errors: ret.reduce((all, e) => {\n            return all.concat([e.errors]);\n          }, [])\n        } : ret[0];\n    }\n\n    function finish (fromValidatePoint, constraintList, neighborhood, recurse, direct, semActHandler, checkValueExpr) {\n      function _dive (solns) {\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n        if (solns.type === \"OneOfSolutions\" ||\n            solns.type === \"EachOfSolutions\") {\n          solns.solutions.forEach(s => {\n            s.expressions.forEach(e => {\n              _dive(e);\n            });\n          });\n        } else if (solns.type === \"TripleConstraintSolutions\") {\n          solns.solutions = solns.solutions.map(x => {\n            if (x.type === \"TestedTriple\") // already done\n              return x; // c.f. validation/3circularRef1_pass-open\n            var t = neighborhood[x.tripleNo];\n            var expr = constraintList[x.constraintNo];\n            var ret = {\n              type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)\n            };\n            function diver (focus, shapeLabel, dive) {\n              var sub = dive(focus, shapeLabel);\n              if (\"errors\" in sub) {\n                // console.dir(sub);\n                var err = {\n                  type: \"ReferenceError\", focus: focus,\n                  shape: shapeLabel\n                };\n                if (typeof shapeLabel === \"string\" && RdfTerm.isBlank(shapeLabel))\n                  err.referencedShape = shape;\n                err.errors = sub;\n                return [err];\n              }\n              if ((\"solution\" in sub || \"solutions\" in sub)&& Object.keys(sub.solution || sub.solutions).length !== 0 ||\n                  sub.type === \"Recursion\")\n                ret.referenced = sub; // !!! needs to aggregate errors and solutions\n              return [];\n            }\n            function diveRecurse (focus, shapeLabel) {\n              return diver(focus, shapeLabel, recurse);\n            }\n            function diveDirect (focus, shapeLabel) {\n              return diver(focus, shapeLabel, direct);\n            }\n            var subErrors = \"valueExpr\" in expr ?\n                checkValueExpr(expr.inverse ? t.subject : t.object, expr.valueExpr, diveRecurse, diveDirect) :\n                [];\n            if (subErrors.length === 0 && \"semActs\" in expr)\n              [].push.apply(subErrors, semActHandler.dispatchAll(expr.semActs, t, ret))\n            if (subErrors.length > 0) {\n              fromValidatePoint.errors = fromValidatePoint.errors || [];\n              fromValidatePoint.errors = fromValidatePoint.errors.concat(subErrors);\n            }\n            return ret;\n          });\n        } else {\n          throw Error(\"unexpected expr type in \" + JSON.stringify(solns));\n        }\n      }\n      if (Object.keys(fromValidatePoint).length > 0) // guard against {}\n        _dive(fromValidatePoint);\n      if (\"semActs\" in shape)\n        fromValidatePoint.semActs = shape.semActs;\n      return fromValidatePoint;\n    }\n  }\n\nfunction extend(base) {\n  if (!base) base = {};\n  for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)\n    for (var name in arg)\n      base[name] = arg[name];\n  return base;\n}\n\nreturn {\n  name: \"eval-threaded-nerr\",\n  description: \"emulation of regular expression engine with error permutations\",\n  compile: vpEngine\n};\n})();\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = EvalThreadedNErr;\n"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "module": "",
          "moduleIdentifier": "",
          "moduleName": "",
          "loc": "shex-webapp-webpack.min",
          "request": "./shex-validator-user.js",
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
      "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-term/shex-term.js",
      "index": 3,
      "index2": 1,
      "size": 10525,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerId": 2,
      "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerPath": [
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "profile": {
            "factory": 19,
            "building": 9
          }
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "profile": {
            "factory": 5,
            "building": 67
          }
        }
      ],
      "profile": {
        "factory": 32,
        "building": 20,
        "dependencies": 23
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "type": "cjs require",
          "userRequest": "@shexjs/term",
          "loc": "31:14-37"
        },
        {
          "moduleId": 5,
          "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "module": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
          "type": "cjs require",
          "userRequest": "@shexjs/term",
          "loc": "2:14-37"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 2,
      "source": "/**\n *\n * isIRI, isBlank, getLiteralType, getLiteralValue\n */\n\nvar ShExTerm = (function () {\n\n  var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,\n    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,\n    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;\n\n  const RdfLangString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\";\n  const XsdString = \"http://www.w3.org/2001/XMLSchema#string\";\n\n  // N3.js:lib/N3Parser.js<0.4.5>:576 with\n  //   s/this\\./Parser./g\n  //   s/token/iri/\n  // ### `_resolveIRI` resolves a relative IRI token against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative.\n  function resolveRelativeIRI (base, iri) {\n\n    if (absoluteIRI.test(iri))\n      return iri\n\n    switch (iri[0]) {\n    // An empty relative IRI indicates the base IRI\n    case undefined: return base;\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      let m = base.match(schemeAuthority);\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? m[1] : m[0]) + _removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default: {\n      return _removeDotSegments(base.replace(/[^\\/?]*(?:\\?.*)?$/, '') + iri);\n    }\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.\n  function _removeDotSegments (iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!dotSegments.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return result + '/' + iri.substr(i + 1);\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  function internalTerm (node) { // !!rdfjsTermToInternal\n    switch (node.termType) {\n    case (\"NamedNode\"):\n      return node.value;\n    case (\"BlankNode\"):\n      return \"_:\" + node.value;\n    case (\"Literal\"):\n      return \"\\\"\" + node.value + \"\\\"\" + (\n        node.datatypeString === RdfLangString\n          ? \"@\" + node.language\n          : node.datatypeString === XsdString\n          ? \"\"\n          : \"^^\" + node.datatypeString\n      );\n    default: throw Error(\"unknown RDFJS node type: \" + JSON.stringify(node))\n    }\n  }\n\n  function internalTriple (triple) { // !!rdfjsTripleToInternal\n    return {\n      subject: internalTerm(triple.subject),\n      predicate: internalTerm(triple.predicate),\n      object: internalTerm(triple.object)\n    };\n  }\n\n  function externalTerm (node, factory) { // !!intermalTermToRdfjs\n    if (isIRI(node)) {\n      return factory.namedNode(node);\n    } else if (isBlank(node)) {\n      return factory.blankNode(node.substr(2));\n    } else if (isLiteral(node)) {\n      let dtOrLang = getLiteralLanguage(node) ||\n          (getLiteralType(node) === XsdString\n           ? null // seems to screw up N3.js\n           : factory.namedNode(getLiteralType(node)))\n      return factory.literal(getLiteralValue(node), dtOrLang)\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  function externalTriple (triple, factory) { // !!rename internalTripleToRdjs\n    return factory.quad(\n      externalTerm(triple.subject, factory),\n      externalTerm(triple.predicate, factory),\n      externalTerm(triple.object, factory)\n    );\n  }\n\n  function intermalTermToTurtle (node, base, prefixes) {\n    if (isIRI(node)) {\n      // if (node === RDF_TYPE) // only valid in Turtle predicates\n      //   return \"a\";\n\n      // Escape special characters\n      if (escape.test(node))\n        node = node.replace(escapeAll, characterReplacer);\n      var pref = Object.keys(prefixes).find(pref => node.startsWith(prefixes[pref]));\n      if (pref) {\n        var rest = node.substr(prefixes[pref].length);\n        if (rest.indexOf(\"\\\\\") === -1) // could also say no more than n of these: [...]\n          return pref + \":\" + rest.replace(/([~!$&'()*+,;=/?#@%])/g, '\\\\' + \"$1\");\n      }\n      if (node.startsWith(base)) {\n        return \"<\" + node.substr(base.length) + \">\";\n      } else {\n        return \"<\" + node + \">\";\n      }\n    } else if (isBlank(node)) {\n      return node;\n    } else if (isLiteral(node)) {\n      var value = getLiteralValue(node);\n      var type = getLiteralType(node);\n      var language = getLiteralLanguage(node);\n      // Escape special characters\n      if (escape.test(value))\n        value = value.replace(escapeAll, characterReplacer);\n      // Write the literal, possibly with type or language\n      if (language)\n        return '\"' + value + '\"@' + language;\n      else if (type)\n        return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);\n      else\n        return '\"' + value + '\"';\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents an IRI in the N3 library\n  function isIRI (entity) {\n    if (typeof entity !== 'string')\n      return false;\n    else if (entity.length === 0)\n      return true;\n    else {\n      var firstChar = entity[0];\n      return firstChar !== '\"' && firstChar !== '_';\n    }\n  }\n\n  // Tests whether the given entity (triple object) represents a literal in the N3 library\n  function isLiteral (entity) {\n    return typeof entity === 'string' && entity[0] === '\"';\n  }\n\n  // Tests whether the given entity (triple object) represents a blank node in the N3 library\n  function isBlank (entity) {\n    return typeof entity === 'string' && entity.substr(0, 2) === '_:';\n  }\n\n  // Tests whether the given entity represents the default graph\n  function isDefaultGraph (entity) {\n    return !entity;\n  }\n\n  // Tests whether the given triple is in the default graph\n  function inDefaultGraph (triple) {\n    return !triple.graph;\n  }\n\n  // Gets the string value of a literal in the N3 library\n  function getLiteralValue (literal) {\n    var match = /^\"([^]*)\"/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1];\n  }\n\n  // Gets the type of a literal in the N3 library\n  function getLiteralType (literal) {\n    var match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^@\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] || (match[2] ? RdfLangString : XsdString);\n  }\n\n  // Gets the language of a literal in the N3 library\n  function getLiteralLanguage (literal) {\n    var match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literal);\n    if (!match)\n      throw new Error(literal + ' is not a literal');\n    return match[1] ? match[1].toLowerCase() : '';\n  }\n\n\n// rdf:type predicate (for 'a' abbreviation)\nvar RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    RDF_TYPE   = RDF_PREFIX + 'type';\n\n// Characters in literals that require escaping\nvar escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapeReplacements = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n  // Replaces a character by its escaped version\n  function characterReplacer (character) {\n    // Replace a single character by its escaped version\n    var result = escapeReplacements[character];\n    if (result === undefined) {\n      // Replace a single character with its 4-bit unicode escape sequence\n      if (character.length === 1) {\n        result = character.charCodeAt(0).toString(16);\n        result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n      }\n      // Replace a surrogate pair with its 8-bit unicode escape sequence\n      else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                  character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n    }\n    return result;\n  }\n\n  return {\n    RdfLangString: RdfLangString,\n    XsdString: XsdString,\n    resolveRelativeIRI: resolveRelativeIRI,\n    isIRI: isIRI,\n    isLiteral: isLiteral,\n    isBlank: isBlank,\n    isDefaultGraph: isDefaultGraph,\n    inDefaultGraph: inDefaultGraph,\n    getLiteralValue: getLiteralValue,\n    getLiteralType: getLiteralType,\n    getLiteralLanguage: getLiteralLanguage,\n    internalTerm: internalTerm,\n    internalTriple: internalTriple,\n    externalTerm: externalTerm,\n    externalTriple: externalTriple,\n    intermalTermToTurtle: intermalTermToTurtle,\n  }\n})();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExTerm; // node environment\n"
    },
    {
      "id": 1,
      "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
      "name": "./shex-validator-user.js",
      "index": 0,
      "index2": 5,
      "size": 71,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "issuerPath": null,
      "profile": {
        "factory": 19,
        "building": 9
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": null,
          "moduleIdentifier": null,
          "module": null,
          "moduleName": null,
          "type": "single entry",
          "userRequest": "./shex-validator-user.js",
          "loc": "shex-webapp-webpack"
        },
        {
          "moduleId": null,
          "moduleIdentifier": null,
          "module": null,
          "moduleName": null,
          "type": "single entry",
          "userRequest": "./shex-validator-user.js",
          "loc": "shex-webapp-webpack.min"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 0,
      "source": "const Validator = require('@shexjs/validator')\nconsole.warn(Validator)\n"
    },
    {
      "id": 2,
      "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "index": 1,
      "index2": 4,
      "size": 47946,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
      "issuerId": 1,
      "issuerName": "./shex-validator-user.js",
      "issuerPath": [
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "profile": {
            "factory": 19,
            "building": 9
          }
        }
      ],
      "profile": {
        "factory": 5,
        "building": 67
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "module": "./shex-validator-user.js",
          "moduleName": "./shex-validator-user.js",
          "type": "cjs require",
          "userRequest": "@shexjs/validator",
          "loc": "1:18-46"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 1,
      "source": "/* ShExValidator - javascript module to validate a graph with respect to Shape Expressions\n *\n * Status: 1/2 tested, no known bugs.\n *\n * TODO:\n *   constraint violation reporting.\n */\n\nvar ShExValidator = (function () {\nvar UNBOUNDED = -1;\n\n// interface constants\nvar Start = { term: \"START\" }\nvar InterfaceOptions = {\n  \"or\": {\n    \"oneOf\": \"exactly one disjunct must pass\",\n    \"someOf\": \"one or more disjuncts must pass\",\n    \"firstOf\": \"disjunct evaluation stops after one passes\"\n  },\n  \"partition\": {\n    \"greedy\": \"each triple constraint consumes all triples matching predicate and object\",\n    \"exhaustive\": \"search all mappings of triples to triple constriant\"\n  }\n};\n\nvar VERBOSE = \"VERBOSE\" in process.env;\n// **ShExValidator** provides ShEx utility functions\n\nvar ProgramFlowError = { type: \"ProgramFlowError\", errors: { type: \"UntrackedError\" } };\n\nvar RdfTerm = require(\"@shexjs/term\");\nlet ShExVisitor = require(\"@shexjs/visitor\");\n\nfunction getLexicalValue (term) {\n  return RdfTerm.isIRI(term) ? term :\n    RdfTerm.isLiteral(term) ? RdfTerm.getLiteralValue(term) :\n    term.substr(2); // bnodes start with \"_:\"\n}\n\n\nvar XSD = \"http://www.w3.org/2001/XMLSchema#\";\nvar integerDatatypes = [\n  XSD + \"integer\",\n  XSD + \"nonPositiveInteger\",\n  XSD + \"negativeInteger\",\n  XSD + \"long\",\n  XSD + \"int\",\n  XSD + \"short\",\n  XSD + \"byte\",\n  XSD + \"nonNegativeInteger\",\n  XSD + \"unsignedLong\",\n  XSD + \"unsignedInt\",\n  XSD + \"unsignedShort\",\n  XSD + \"unsignedByte\",\n  XSD + \"positiveInteger\"\n];\n\nvar decimalDatatypes = [\n  XSD + \"decimal\",\n].concat(integerDatatypes);\n\nvar numericDatatypes = [\n  XSD + \"float\",\n  XSD + \"double\"\n].concat(decimalDatatypes);\n\nvar numericParsers = {};\nnumericParsers[XSD + \"integer\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?[0-9]+$/))) {\n    parseError(\"illegal integer value '\" + label + \"'\");\n  }\n  return parseInt(label);\n};\nnumericParsers[XSD + \"decimal\"] = function (label, parseError) {\n  if (!(label.match(/^[+-]?(?:[0-9]*\\.[0-9]+|[0-9]+)$/))) { // XSD has no pattern for decimal?\n    parseError(\"illegal decimal value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nconst DECIMAL_REGEX = /^[+\\-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[eE][+\\-]?[0-9]+)?$/;\nnumericParsers[XSD + \"float\"  ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) { // XSD has no pattern for float?\n    parseError(\"illegal float value '\" + label + \"'\");\n  }\n  return parseFloat(label);\n};\nnumericParsers[XSD + \"double\" ] = function (label, parseError) {\n  if (label === \"NaN\") return NaN;\n  if (label === \"INF\") return Infinity;\n  if (label === \"-INF\") return -Infinity;\n  if (!(label.match(DECIMAL_REGEX))) {\n    parseError(\"illegal double value '\" + label + \"'\");\n  }\n  return Number(label);\n};\n\ntestRange = function (value, datatype, parseError) {\n  const ranges = {\n    //    integer            -1 0 1 +1 | \"\" -1.0 +1.0 1e0 NaN INF\n    //    decimal            -1 0 1 +1 -1.0 +1.0 | \"\" 1e0 NaN INF\n    //    float              -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    double             -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n    //    nonPositiveInteger -1 0 +0 -0 | 1 +1 1a a1\n    //    negativeInteger    -1 | 0 +0 -0 1\n    //    long               -1 0 1 +1 |\n    //    int                -1 0 1 +1 |\n    //    short              -32768 0 32767 | -32769 32768\n    //    byte               -128 0 127 | \"\" -129 128\n    //    nonNegativeInteger 0 -0 +0 1 +1 | -1\n    //    unsignedLong       0 1 | -1\n    //    unsignedInt        0 1 | -1\n    //    unsignedShort      0 65535 | -1 65536\n    //    unsignedByte       0 255 | -1 256\n    //    positiveInteger    1 | -1 0\n    //    string             \"\" \"a\" \"0\"\n    //    boolean            true false 0 1 | \"\" TRUE FALSE tRuE fAlSe -1 2 10 01\n    //    dateTime           \"2012-01-02T12:34:56.78Z\" | \"\" \"2012-01-02T\" \"2012-01-02\"\n    integer:            { min: -Infinity           , max: Infinity },\n    decimal:            { min: -Infinity           , max: Infinity },\n    float:              { min: -Infinity           , max: Infinity },\n    double:             { min: -Infinity           , max: Infinity },\n    nonPositiveInteger: { min: -Infinity           , max: 0        },\n    negativeInteger:    { min: -Infinity           , max: -1       },\n    long:               { min: -9223372036854775808, max: 9223372036854775807 },\n    int:                { min: -2147483648         , max: 2147483647 },\n    short:              { min: -32768              , max: 32767    },\n    byte:               { min: -128                , max: 127      },\n    nonNegativeInteger: { min: 0                   , max: Infinity },\n    unsignedLong:       { min: 0                   , max: 18446744073709551615 },\n    unsignedInt:        { min: 0                   , max: 4294967295 },\n    unsignedShort:      { min: 0                   , max: 65535    },\n    unsignedByte:       { min: 0                   , max: 255      },\n    positiveInteger:    { min: 1                   , max: Infinity }\n  }\n  var parms = ranges[datatype.substr(XSD.length)];\n  if (!parms) throw Error(\"unexpected datatype: \" + datatype);\n  if (value < parms.min) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is less than the min:\", parms.min);\n  } else if (value > parms.max) {\n    parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is greater than the max:\", parms.min);\n  }\n};\n\n/*\nfunction intSubType (spec, label, parseError) {\n  var ret = numericParsers[XSD + \"integer\"](label, parseError);\n  if (\"min\" in spec && ret < spec.min)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be < \" + spec.min);\n  if (\"max\" in spec && ret > spec.max)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be > \" + spec.max);\n  return ret;\n}\n[{type: \"nonPositiveInteger\", max: 0},\n {type: \"negativeInteger\", max: -1},\n {type: \"long\", min: -9223372036854775808, max: 9223372036854775807}, // beyond IEEE double\n {type: \"int\", min: -2147483648, max: 2147483647},\n {type: \"short\", min: -32768, max: 32767},\n {type: \"byte\", min: -128, max: 127},\n {type: \"nonNegativeInteger\", min: 0},\n {type: \"unsignedLong\", min: 0, max: 18446744073709551615},\n {type: \"unsignedInt\", min: 0, max: 4294967295},\n {type: \"unsignedShort\", min: 0, max: 65535},\n {type: \"unsignedByte\", min: 0, max: 255},\n {type: \"positiveInteger\", min: 1}].forEach(function (i) {\n   numericParsers[XSD + i.type ] = function (label, parseError) {\n     return intSubType(i, label, parseError);\n   };\n });\n*/\n\nvar stringTests = {\n  length   : function (v, l) { return v.length === l; },\n  minlength: function (v, l) { return v.length  >= l; },\n  maxlength: function (v, l) { return v.length  <= l; }\n};\n\nvar numericValueTests = {\n  mininclusive  : function (n, m) { return n >= m; },\n  minexclusive  : function (n, m) { return n >  m; },\n  maxinclusive  : function (n, m) { return n <= m; },\n  maxexclusive  : function (n, m) { return n <  m; }\n};\n\nvar decimalLexicalTests = {\n  totaldigits   : function (v, d) {\n    var m = v.match(/[0-9]/g);\n    return m && m.length <= d;\n  },\n  fractiondigits: function (v, d) {\n    var m = v.match(/^[+-]?[0-9]*\\.?([0-9]*)$/);\n    return m && m[1].length <= d;\n  }\n};\n\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n/* ShExValidator_constructor - construct an object for validating a schema.\n *\n * schema: a structure produced by a ShEx parser or equivalent.\n * options: object with controls for\n *   lax(true): boolean: whine about missing types in schema.\n *   diagnose(false): boolean: makde validate return a structure with errors.\n */\nfunction ShExValidator_constructor(schema, options) {\n  if (!(this instanceof ShExValidator_constructor))\n    return new ShExValidator_constructor(schema, options);\n  let index = schema._index || ShExVisitor.index(schema)\n  this.type = \"ShExValidator\";\n  options = options || {};\n  this.options = options;\n  this.options.or = this.options.or || \"someOf\";\n  this.options.partition = this.options.partition || \"exhaustive\";\n  if (!(\"noCache\" in options && options.noCache))\n    this.known = {};\n\n  var _ShExValidator = this;\n  this.schema = schema;\n  this._expect = this.options.lax ? noop : expect; // report errors on missing types.\n  this._optimize = {}; // optimizations:\n    // hasRepeatedGroups: whether there are patterns like (:p1 ., :p2 .)*\n  this.reset = function () {  }; // included in case we need it later.\n  // var regexModule = this.options.regexModule || require(\"@shexjs/eval-simple-1err\");\n  var regexModule = this.options.regexModule || require(\"@shexjs/eval-threaded-nerr\");\n\n  /* getAST - compile a traditional regular expression abstract syntax tree.\n   * Tested but not used at present.\n   */\n  this.getAST = function () {\n    return {\n      type: \"AST\",\n      shapes: schema.shapes.reduce(function (ret, shape) {\n        ret[shape.id] = {\n          type: \"ASTshape\",\n          expression: _compileShapeToAST(shape.expression, [], _ShExValidator.schema)\n        };\n        return ret;\n      }, {})\n    };\n  };\n\n  /* indexTripleConstraints - compile regular expression and index triple constraints\n   */\n  this.indexTripleConstraints = function (expression) {\n    // list of triple constraints from (:p1 ., (:p2 . | :p3 .))\n    var tripleConstraints = [];\n\n    if (expression)\n      indexTripleConstraints_dive(expression);\n    return tripleConstraints;\n\n    function indexTripleConstraints_dive (expr) {\n      if (typeof expr === \"string\") // Inclusion\n        indexTripleConstraints_dive(index.tripleExprs[expr]);\n\n      else if (expr.type === \"TripleConstraint\")\n        tripleConstraints.push(expr)-1;\n\n      else if (expr.type === \"OneOf\" || expr.type === \"EachOf\")\n        expr.expressions.forEach(function (nested) {\n          indexTripleConstraints_dive(nested);\n        });\n\n      // @@TODO shape.virtual, shape.inherit\n      else\n        runtimeError(\"unexpected expr type: \" + expr.type);\n    };\n  };\n\n  /* emptyTracker - a tracker that does nothing\n   */\n  this.emptyTracker = function () {\n    var noop = x => x;\n    return {\n      recurse: noop,\n      known: noop,\n      enter: function (point, label) { ++this.depth; },\n      exit: function (point, label, ret) { --this.depth; },\n      depth: 0\n    };\n  };\n\n  /* validate - test point in db against the schema for labelOrShape\n   * depth: level of recurssion; for logging.\n   */\n  this.validate = function (db, point, label, tracker, seen) {\n    // default to schema's start shape\n    if (typeof point === \"object\" && \"termType\" in point) {\n      point = RdfTerm.internalTerm(point)\n    }\n    if (typeof point === \"object\") {\n      var shapeMap = point;\n      if (this.options.results === \"api\") {\n        return shapeMap.map(pair => {\n          var time = new Date();\n          var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n          time = new Date() - time;\n          return {\n            node: pair.node,\n            shape: pair.shape,\n            status: \"errors\" in res ? \"nonconformant\" : \"conformant\",\n            appinfo: res,\n            elapsed: time\n          };\n        });\n      }\n      var results = shapeMap.reduce((ret, pair) => {\n        var res = this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n        return \"errors\" in res ?\n          { passes: ret.passes, failures: ret.failures.concat(res) } :\n          { passes: ret.passes.concat(res), failures: ret.failures } ;\n      }, {passes: [], failures: []});\n      if (false && this.options.results === \"api\") {\n        var ret = {};\n        function _add (n, s, r) {\n          if (!(n in ret)) {\n            ret[n] = [{shape: s, result: r}];\n            return;\n          }\n          if (ret[n].filter(p => { return p.shape === s; }))\n            return;\n          ret[n].push({shape: s, results: r});\n        }\n        results.passes.forEach(p => { _add(p.node, p.shape, true); });\n        results.failures.forEach(p => { _add(p.node, p.shape, false); });\n        return ret;\n      }\n      if (results.failures.length) {\n        return results.failures.length !== 1 ?\n          { type: \"FailureList\", errors: results.failures } :\n          results.failures [0];\n      } else {\n        return results.passes.length !== 1 ?\n          { type: \"SolutionList\", solutions: results.passes } :\n          results.passes [0];\n      }\n    }\n\n    var outside = tracker === undefined;\n    // logging stuff\n    if (!tracker)\n      tracker = this.emptyTracker();\n    if (!label || label === Start) {\n      if (!schema.start)\n        runtimeError(\"start production not defined\");\n    }\n\n    var shape = null;\n    if (label == Start) {\n      shape = schema.start;\n    } else if (!(\"shapes\" in this.schema) || this.schema.shapes.length === 0) {\n      runtimeError(\"shape \" + label + \" not found; no shapes in schema\");\n    } else if (label in index.shapeExprs) {\n      shape = index.shapeExprs[label]\n    } else {\n      runtimeError(\"shape \" + label + \" not found in:\\n\" + Object.keys(index.shapeExprs || []).map(s => \"  \" + s).join(\"\\n\"));\n    }\n\n    if (seen === undefined)\n      seen = {};\n    var seenKey = point + \"@\" + (label === Start ? \"_: -start-\" : label);\n    if (seenKey in seen)\n      return tracker.recurse({\n        type: \"Recursion\",\n        node: ldify(point),\n        shape: label\n      });\n    if (\"known\" in this && seenKey in this.known)\n      return tracker.known(this.known[seenKey]);\n    seen[seenKey] = { point: point, shape: label };\n    tracker.enter(point, label);\n    var ret = this._validateShapeExpr(db, point, shape, label, tracker, seen);\n    tracker.exit(point, label, ret);\n    delete seen[seenKey];\n    if (\"known\" in this)\n      this.known[seenKey] = ret;\n    if (\"startActs\" in schema && outside) {\n      ret.startActs = schema.startActs;\n    }\n    return ret;\n  }\n\n  this._validateShapeExpr = function (db, point, shapeExpr, shapeLabel, tracker, seen) {\n    if (point === \"\")\n      throw Error(\"validation needs a valid focus node\");\n    if (typeof shapeExpr === \"string\") { // ShapeRef\n      return this._validateShapeExpr(db, point, index.shapeExprs[shapeExpr], shapeExpr, tracker, seen);\n    } else if (shapeExpr.type === \"NodeConstraint\") {\n      var errors = this._errorsMatchingNodeConstraint(point, shapeExpr, null);\n      return errors.length ? {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors.map(function (error) {\n          return {\n            type: \"NodeConstraintViolation\",\n            shapeExpr: shapeExpr,\n            error: error\n          };\n        })\n      } : {\n        type: \"NodeTest\",\n        node: ldify(point),\n        shape: shapeLabel,\n        shapeExpr: shapeExpr\n      };\n    } else if (shapeExpr.type === \"Shape\") {\n      return this._validateShape(db, point, regexModule.compile(schema, shapeExpr, index),\n                                 shapeExpr, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeExternal\") {\n      return this.options.validateExtern(db, point, shapeLabel, tracker, seen);\n    } else if (shapeExpr.type === \"ShapeOr\") {\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          return { type: \"ShapeOrResults\", solution: sub };\n      }\n      return { type: \"ShapeOrFailure\", errors: errors };\n    } else if (shapeExpr.type === \"ShapeNot\") {\n      var sub = this._validateShapeExpr(db, point, shapeExpr.shapeExpr, shapeLabel, tracker, seen);\n      if (\"errors\" in sub)\n          return { type: \"ShapeNotResults\", solution: sub };\n        else\n          return { type: \"ShapeNotFailure\", errors: sub };\n    } else if (shapeExpr.type === \"ShapeAnd\") {\n      var passes = [];\n      var errors = [];\n      for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n        var nested = shapeExpr.shapeExprs[i];\n        var sub = this._validateShapeExpr(db, point, nested, shapeLabel, tracker, seen);\n        if (\"errors\" in sub)\n          errors.push(sub);\n        else\n          passes.push(sub);\n      }\n      if (errors.length > 0) {\n        return  { type: \"ShapeAndFailure\", errors: errors};\n      }\n      return { type: \"ShapeAndResults\", solutions: passes };\n    } else\n      throw Error(\"expected one of Shape{Ref,And,Or} or NodeConstraint, got \" + JSON.stringify(shapeExpr));\n  }\n\n  this._validateShape = function (db, point, regexEngine, shape, shapeLabel, tracker, seen) {\n    var _ShExValidator = this;\n\n    var ret = null;\n    var startAcionStorage = {}; // !!! need test to see this write to results structure.\n    if (\"startActs\" in schema) {\n      const semActErrors = this.semActHandler.dispatchAll(schema.startActs, null, startAcionStorage)\n      if (semActErrors.length)\n        return {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: semActErrors\n        }; // some semAct aborted !! return real error\n    }\n    // @@ add to tracker: f(\"validating <\" + point + \"> as <\" + shapeLabel + \">\");\n\n    var fromDB  = db.getNeighborhood(point, shapeLabel, shape);\n    var outgoing = indexNeighborhood(fromDB.outgoing.sort(\n      (l, r) => sparqlOrder(l.object, r.object)\n    ));\n    var incoming = indexNeighborhood(fromDB.incoming.sort(\n      (l, r) => sparqlOrder(l.subject, r.subject)\n    ));\n    var outgoingLength = fromDB.outgoing.length;\n    var neighborhood = fromDB.outgoing.concat(fromDB.incoming);\n\n    var constraintList = this.indexTripleConstraints(shape.expression);\n    var tripleList = constraintList.reduce(function (ret, constraint, ord) {\n\n      // subject and object depend on direction of constraint.\n      var searchSubject = constraint.inverse ? null : point;\n      var searchObject = constraint.inverse ? point : null;\n      var index = constraint.inverse ? incoming : outgoing;\n\n      // get triples matching predciate\n      var matchPredicate = index.byPredicate[constraint.predicate] ||\n        []; // empty list when no triple matches that constraint\n\n      function _errorsByShapeLabel (focus, shapeLabel) {\n        var sub = _ShExValidator.validate(db, focus, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      function _errorsByShapeExpr (focus, shapeExpr) {\n        var sub = _ShExValidator._validateShapeExpr(db, focus, shapeExpr, shapeLabel, tracker, seen);\n        return \"errors\" in sub ? sub.errors : [];\n      }\n      // strip to triples matching value constraints (apart from @<someShape>)\n      var matchConstraints = _ShExValidator._triplesMatchingShapeExpr(\n        matchPredicate,\n        constraint.valueExpr,\n        constraint.inverse,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeLabel,\n        /* _ShExValidator.options.partition === \"exhaustive\" ? undefined : */ _errorsByShapeExpr\n      );\n\n      matchConstraints.hits.forEach(function (t) {\n        ret.constraintList[neighborhood.indexOf(t)].push(ord);\n      });\n      matchConstraints.misses.forEach(function (t) {\n        ret.misses[neighborhood.indexOf(t.triple)] = {constraintNo: ord, errors: t.errors};\n      });\n      return ret;\n    }, { misses: {}, constraintList:_seq(neighborhood.length).map(function () { return []; }) }); // start with [[],[]...]\n\n    // @@ add to tracker: f(\"constraints by triple: \", JSON.stringify(tripleList.constraintList));\n\n    var extras = []; // triples accounted for by EXTRA\n    var misses = tripleList.constraintList.reduce(function (ret, constraints, ord) {\n      if (constraints.length === 0 &&                       // matches no constraints\n          ord < outgoingLength &&                           // not an incoming triple\n          ord in tripleList.misses) {                       // predicate matched some constraint(s)\n        if (shape.extra !== undefined &&\n            shape.extra.indexOf(neighborhood[ord].predicate) !== -1) {\n          extras.push(ord);\n        } else {                                            // not declared extra\n          ret.push({                                        // so it's a missed triple.\n            tripleNo: ord,\n            constraintNo: tripleList.misses[ord].constraintNo,\n            errors: tripleList.misses[ord].errors\n          });\n        }\n      }\n      return ret;\n    }, []);\n\n    var xp = crossProduct(tripleList.constraintList);\n    var partitionErrors = [];\n    while ((misses.length === 0 || this.options.partition !== \"greedy\") && xp.next() && ret === null) {\n      // caution: early continues\n\n      var usedTriples = []; // [{s1,p1,o1},{s2,p2,o2}] implicated triples -- used for messages\n      var constraintMatchCount = // [2,1,0,1] how many triples matched a constraint\n        _seq(neighborhood.length).map(function () { return 0; });\n      var tripleToConstraintMapping = xp.get(); // [0,1,0,3] mapping from triple to constraint\n\n      // Triples not mapped to triple constraints are not allowed in closed shapes.\n      if (shape.closed) {\n        var unexpectedTriples = neighborhood.slice(0, outgoingLength).filter((t, i) => {\n          return tripleToConstraintMapping[i] === undefined && // didn't match a constraint\n          extras.indexOf(i) === -1; // wasn't in EXTRAs.\n        });\n        if (unexpectedTriples.length > 0) {\n          partitionErrors.push({\n            errors: [\n              {\n                type: \"ClosedShapeViolation\",\n                unexpectedTriples: unexpectedTriples\n              }\n            ]\n          });\n          continue; // closed shape violation.\n        }\n      }\n\n      // Set usedTriples and constraintMatchCount.\n      tripleToConstraintMapping.forEach(function (tpNumber, ord) {\n        if (tpNumber !== undefined) {\n          usedTriples.push(neighborhood[ord]);\n          ++constraintMatchCount[tpNumber];\n        }\n      });\n\n      // Pivot to triples by constraint.\n      function _constraintToTriples () {\n        var cll = constraintList.length;\n        return tripleToConstraintMapping.slice().\n          reduce(function (ret, c, ord) {\n            if (c !== undefined)\n              ret[c].push(ord);\n            return ret;\n          }, _seq(cll).map(function () { return []; }));\n      }\n\n      tripleToConstraintMapping.slice().sort(function (a,b) { return a-b; }).filter(function (i) { // sort constraint numbers\n        return i !== undefined;\n      }).map(function (n) { return n + \" \"; }).join(\"\"); // e.g. 0 0 1 3\n\n      function _recurse (point, shapeLabel) {\n        return _ShExValidator.validate(db, point, shapeLabel, tracker, seen);\n      }\n      function _direct (point, shapeExpr) {\n        return _ShExValidator._validateShapeExpr(db, point, shapeExpr, shapeLabel, tracker, seen);\n      }\n      function _testExpr (term, valueExpr, recurse, direct) {\n        return _ShExValidator._errorsMatchingShapeExpr(term, valueExpr, recurse, direct)\n      }\n      var results = regexEngine.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, _direct, this.semActHandler, _testExpr, null);\n      // {// testing parity between two engines\n      //   var nfa = require(\"@shexjs/eval-simple-1err\").compile(schema, shape);\n      //   var fromNFA = nfa.match(db, point, constraintList, _constraintToTriples(), tripleToConstraintMapping, neighborhood, _recurse, this.semActHandler, _testExpr, null);\n      //   if (\"errors\" in fromNFA !== \"errors\" in results)\n      //     { throw Error(JSON.stringify(results) + \" vs \" + JSON.stringify(fromNFA)); }\n      // }\n      if (\"errors\" in results) {\n        partitionErrors.push({\n          errors: results.errors\n        });\n        if (_ShExValidator.options.partition !== \"exhaustive\")\n          break;\n        else\n          continue;\n      }\n\n      // @@ add to tracker: f(\"post-regexp \" + usedTriples.join(\" \"));\n\n      var possibleRet = { type: \"ShapeTest\", node: ldify(point), shape: shapeLabel };\n      if (Object.keys(results).length > 0) // only include .solution for non-empty pattern\n        possibleRet.solution = results;\n      if (\"semActs\" in shape) {\n        const semActErrors = this.semActHandler.dispatchAll(shape.semActs, results, possibleRet)\n        if (semActErrors.length) {\n          // some semAct aborted\n          partitionErrors.push({\n            errors: semActErrors\n          });\n          if (_ShExValidator.options.partition !== \"exhaustive\")\n            break;\n          else\n            continue;\n        }\n      }\n      // @@ add to tracker: f(\"final \" + usedTriples.join(\" \"));\n\n      ret = possibleRet;\n      partitionErrors = [];\n      // alts.push(tripleToConstraintMapping);\n    }\n    var missErrors = misses.map(function (miss) {\n      var t = neighborhood[miss.tripleNo];\n      return {\n        type: \"TypeMismatch\",\n        triple: {type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)},\n        constraint: constraintList[miss.constraintNo],\n        errors: miss.errors\n      };\n    });\n    let errors = missErrors.concat(partitionErrors.length === 1 ? partitionErrors[0].errors : partitionErrors);\n    if (errors.length > 0) {\n      ret = {\n        type: \"Failure\",\n        node: ldify(point),\n        shape: shapeLabel,\n        errors: errors\n      };\n    }\n\n    if (VERBOSE) { // remove N3jsTripleToString\n      neighborhood.forEach(function (t) {\n        delete t.toString;\n      });\n    }\n    // @@ add to tracker: f(\"</\" + shapeLabel + \">\");\n    return addShapeAttributes(ret);\n\n    function addShapeAttributes (ret) {\n      if (\"annotations\" in shape)\n        ret.annotations = shape.annotations;\n      return ret;\n    }\n  };\n\n  this._triplesMatchingShapeExpr = function (triples, valueExpr, inverse, recurse, direct) {\n    var _ShExValidator = this;\n    var misses = [];\n    var hits = [];\n    triples.forEach(function (triple) {\n      var value = inverse ? triple.subject : triple.object;\n      var errors = valueExpr === undefined ?\n          [] :\n          _ShExValidator._errorsMatchingShapeExpr(value, valueExpr, recurse, direct);\n      if (errors.length === 0) {\n        hits.push(triple);\n      } else if (hits.indexOf(triple) === -1) {\n        misses.push({triple: triple, errors: errors});\n      }\n    });\n    return { hits: hits, misses: misses };\n  }\n  this._errorsMatchingShapeExpr = function (value, valueExpr, recurse, direct) {\n    var _ShExValidator = this;\n    if (typeof valueExpr === \"string\") { // ShapeRef\n      return recurse ? recurse(value, valueExpr) : [];\n    } else if (valueExpr.type === \"NodeConstraint\") {\n      return this._errorsMatchingNodeConstraint(value, valueExpr, null);\n    } else if (valueExpr.type === \"Shape\") {\n      return direct === undefined ? [] : direct(value, valueExpr);\n    } else if (valueExpr.type === \"ShapeOr\") {\n      var ret = [];\n      for (var i = 0; i < valueExpr.shapeExprs.length; ++i) {\n        var nested = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExprs[i], recurse, direct);\n        if (nested.length === 0)\n          return nested;\n        ret = ret.concat(nested);\n      }\n      return ret;\n    } else if (valueExpr.type === \"ShapeAnd\") {\n      return valueExpr.shapeExprs.reduce(function (ret, nested, iter) {\n        return ret.concat(_ShExValidator._errorsMatchingShapeExpr(value, nested, recurse, direct, true));\n      }, []);\n    } else if (valueExpr.type === \"ShapeNot\") {\n      var ret = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExpr, recurse, direct, true);\n      return ret.length ?\n        [] :\n        [\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": expected NOT to pass\"];\n    } else {\n      throw Error(\"unknown value expression type '\" + valueExpr.type + \"'\");\n    }\n  };\n\n  /* _errorsMatchingNodeConstraint - return whether the value matches the value\n   * expression without checking shape references.\n   */\n  this._errorsMatchingNodeConstraint = function (value, valueExpr, recurse) {\n    var errors = [];\n    var label = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralValue(value) :\n      RdfTerm.isBlank(value) ? value.substring(2) :\n      value;\n    var dt = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralType(value) : null;\n    var numeric = integerDatatypes.indexOf(dt) !== -1 ? XSD + \"integer\" : numericDatatypes.indexOf(dt) !== -1 ? dt : undefined;\n\n    function validationError () {\n      var errorStr = Array.prototype.join.call(arguments, \"\");\n      errors.push(\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": \" + errorStr);\n      return false;\n    }\n    // if (negated) ;\n    if (false) {\n      // wildcard -- ignore\n    } else {\n      if (\"nodeKind\" in valueExpr) {\n        if ([\"iri\", \"bnode\", \"literal\", \"nonliteral\"].indexOf(valueExpr.nodeKind) === -1) {\n          validationError(\"unknown node kind '\" + valueExpr.nodeKind + \"'\");\n        }\n        if (RdfTerm.isBlank(value)) {\n          if (valueExpr.nodeKind === \"iri\" || valueExpr.nodeKind === \"literal\") {\n            validationError(\"blank node found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (RdfTerm.isLiteral(value)) {\n          if (valueExpr.nodeKind !== \"literal\") {\n            validationError(\"literal found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        } else if (valueExpr.nodeKind === \"bnode\" || valueExpr.nodeKind === \"literal\") {\n          validationError(\"iri found when \" + valueExpr.nodeKind + \" expected\");\n        }\n      }\n\n      if (valueExpr.datatype  && valueExpr.values  ) validationError(\"found both datatype and values in \"   +tripleConstraint);\n\n      if (valueExpr.datatype) {\n        if (!RdfTerm.isLiteral(value)) {\n          validationError(\"mismatched datatype: \" + value + \" is not a literal with datatype \" + valueExpr.datatype);\n        }\n        else if (RdfTerm.getLiteralType(value) !== valueExpr.datatype) {\n          validationError(\"mismatched datatype: \" + RdfTerm.getLiteralType(value) + \" !== \" + valueExpr.datatype);\n        }\n        else if (numeric) {\n          testRange(numericParsers[numeric](label, validationError), valueExpr.datatype, validationError);\n        }\n        else if (valueExpr.datatype === XSD + \"boolean\") {\n          if (label !== \"true\" && label !== \"false\" && label !== \"1\" && label !== \"0\")\n            validationError(\"illegal boolean value: \" + label);\n        }\n        else if (valueExpr.datatype === XSD + \"dateTime\") {\n          if (!label.match(/^[+-]?\\d{4}-[01]\\d-[0-3]\\dT[0-5]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?([+-][0-2]\\d:[0-5]\\d|Z)?$/))\n            validationError(\"illegal dateTime value: \" + label);\n        }\n      }\n\n      if (valueExpr.values) {\n        if (RdfTerm.isLiteral(value) && valueExpr.values.reduce((ret, v) => {\n          if (ret) return true;\n          var ld = ldify(value);\n          if (v.type === \"Language\") {\n            return v.languageTag === ld.language; // @@ use equals/normalizeTest\n          }\n          if (!(typeof v === \"object\" && \"value\" in v))\n            return false;\n          return v.value === ld.value &&\n            v.type === ld.type &&\n            v.language === ld.language;\n        }, false)) {\n          // literal match\n        } else if (valueExpr.values.indexOf(value) !== -1) {\n          // trivial match\n        } else {\n          if (!(valueExpr.values.some(function (valueConstraint) {\n            if (typeof valueConstraint === \"object\" && !(\"value\" in valueConstraint)) { // isTerm me -- strike \"value\" in\n              if (!(\"type\" in valueConstraint))\n                runtimeError(\"expected \"+JSON.stringify(valueConstraint)+\" to have a 'type' attribute.\");\n              var stemRangeTypes = [\n                \"Language\",\n                \"IriStem\",      \"LiteralStem\",      \"LanguageStem\",\n                \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"\n              ];\n              if (stemRangeTypes.indexOf(valueConstraint.type) === -1)\n                runtimeError(\"expected type attribute '\"+valueConstraint.type+\"' to be in '\"+stemRangeTypes+\"'.\");\n\n              /* expect N3.js literals with {Literal,Language}StemRange\n               *       or non-literals with IriStemRange\n               */\n              function normalizedTest (val, ref, func) {\n                if (RdfTerm.isLiteral(val)) {\n                  if ([\"LiteralStem\", \"LiteralStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralValue(val), ref);\n                  } else if ([\"LanguageStem\", \"LanguageStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                    return func(RdfTerm.getLiteralLanguage(val) || null, ref);\n                  } else {\n                    return validationError(\"literal \" + val + \" not comparable with non-literal \" + ref);\n                  }\n                } else {\n                  if ([\"IriStem\", \"IriStemRange\"].indexOf(valueConstraint.type) === -1) {\n                    return validationError(\"nonliteral \" + val + \" not comparable with literal \" + JSON.stringify(ref));\n                  } else {\n                    return func(val, ref);\n                  }\n                }\n              }\n              function startsWith (val, ref) {\n                return normalizedTest(val, ref, (l, r) => {\n                  return (valueConstraint.type === \"LanguageStem\" ||\n                          valueConstraint.type === \"LanguageStemRange\") ?\n                    // rfc4647 basic filtering\n                    l !== null && (l === r || r === \"\" || l[r.length] === \"-\") :\n                    // simple substring\n                    l.startsWith(r);\n                });\n              }\n              function equals (val, ref) {\n                return normalizedTest(val, ref, (l, r) => { return l === r; });\n              }\n\n              if (!isTerm(valueConstraint.stem)) {\n                expect(valueConstraint.stem, \"type\", \"Wildcard\");\n                // match whatever but check exclusions below\n              } else {\n                if (!(startsWith(value, valueConstraint.stem))) {\n                  return false;\n                }\n              }\n              if (valueConstraint.exclusions) {\n                return !valueConstraint.exclusions.some(function (c) {\n                  if (!isTerm(c)) {\n                    if (!(\"type\" in c))\n                      runtimeError(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\");\n                    var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n                    if (stemTypes.indexOf(c.type) === -1)\n                      runtimeError(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\");\n                    return startsWith(value, c.stem);\n                  } else {\n                    return equals(value, c);\n                  }\n                });\n              }\n              return true;\n            } else {\n              // ignore -- would have caught it above\n            }\n          }))) {\n            validationError(\"value \" + value + \" not found in set \" + JSON.stringify(valueExpr.values));\n          }\n        }\n      }\n    }\n\n    if (\"pattern\" in valueExpr) {\n      var regexp = \"flags\" in valueExpr ?\n\t  new RegExp(valueExpr.pattern, valueExpr.flags) :\n\t  new RegExp(valueExpr.pattern);\n      if (!(getLexicalValue(value).match(regexp)))\n        validationError(\"value \" + getLexicalValue(value) + \" did not match pattern \" + valueExpr.pattern);\n    }\n\n    Object.keys(stringTests).forEach(function (test) {\n      if (test in valueExpr && !stringTests[test](label, valueExpr[test])) {\n        validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n      }\n    });\n\n    Object.keys(numericValueTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric) {\n          if (!numericValueTests[test](numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n\n    Object.keys(decimalLexicalTests).forEach(function (test) {\n      if (test in valueExpr) {\n        if (numeric === XSD + \"integer\" || numeric === XSD + \"decimal\") {\n          if (!decimalLexicalTests[test](\"\"+numericParsers[numeric](label, validationError), valueExpr[test])) {\n            validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n          }\n        } else {\n          validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n        }\n      }\n    });\n    return errors;\n  };\n\n  this.semActHandler = {\n    handlers: { },\n    results: { },\n    /**\n     * Store a semantic action handler.\n     *\n     * @param {string} name - semantic action's URL.\n     * @param {object} handler - handler function.\n     *\n     * The handler object has a dispatch function is invoked with:\n     * @param {string} code - text of the semantic action.\n     * @param {object} ctx - matched triple or results subset.\n     * @param {object} extensionStorage - place where the extension writes into the result structure.\n     * @return {bool} false if the extension failed or did not accept the ctx object.\n     */\n    register: function (name, handler) {\n      this.handlers[name] = handler;\n    },\n    /**\n     * Calls all semantic actions, allowing each to write to resultsArtifact.\n     *\n     * @param {array} semActs - list of semantic actions to invoke.\n     * @return {bool} false if any result was false.\n     */\n    dispatchAll: function (semActs, ctx, resultsArtifact) {\n      var _semActHanlder = this;\n      return semActs.reduce(function (ret, semAct) {\n        if (ret.length === 0 && semAct.name in _semActHanlder.handlers) {\n          var code = \"code\" in semAct ? semAct.code : _ShExValidator.options.semActs[semAct.name];\n          var existing = \"extensions\" in resultsArtifact && semAct.name in resultsArtifact.extensions;\n          var extensionStorage = existing ? resultsArtifact.extensions[semAct.name] : {};\n          const response = _semActHanlder.handlers[semAct.name].dispatch(code, ctx, extensionStorage); debugger\n          if (typeof response === 'boolean') {\n            if (!response)\n              ret.push({ type: \"SemActFailure\", errors: [{ type: \"BooleanSemActFailure\", code: code, ctx }] })\n          } else if (typeof response === 'object' && response.constructor === Array) {\n            if (response.length > 0)\n              ret.push({ type: \"SemActFailure\", errors: response })\n          } else {\n            throw Error(\"unsupported response from semantic action handler: \" + JSON.stringify(response))\n          }\n          if (!existing && Object.keys(extensionStorage).length > 0) {\n            if (!(\"extensions\" in resultsArtifact))\n              resultsArtifact.extensions = {};\n            resultsArtifact.extensions[semAct.name] = extensionStorage;\n          }\n          return ret;\n        }\n        return ret;\n      }, []);\n    }\n  };\n}\n\n/* _compileShapeToAST - compile a shape expression to an abstract syntax tree.\n *\n * currently tested but not used.\n */\nfunction _compileShapeToAST (expression, tripleConstraints, schema) {\n\n  function Epsilon () {\n    this.type = \"Epsilon\";\n  }\n\n  function TripleConstraint (ordinal, predicate, inverse, negated, valueExpr) {\n    this.type = \"TripleConstraint\";\n    // this.ordinal = ordinal; @@ does 1card25\n    this.inverse = !!inverse;\n    this.negated = !!negated;\n    this.predicate = predicate;\n    if (valueExpr !== undefined)\n      this.valueExpr = valueExpr;\n  }\n\n  function Choice (disjuncts) {\n    this.type = \"Choice\";\n    this.disjuncts = disjuncts;\n  }\n\n  function EachOf (conjuncts) {\n    this.type = \"EachOf\";\n    this.conjuncts = conjuncts;\n  }\n\n  function SemActs (expression, semActs) {\n    this.type = \"SemActs\";\n    this.expression = expression;\n    this.semActs = semActs;\n  }\n\n  function KleeneStar (expression) {\n    this.type = \"KleeneStar\";\n    this.expression = expression;\n  }\n\n  function _compileExpression (expr, schema) {\n    var repeated, container;\n\n    /* _repeat: map expr with a min and max cardinality to a corresponding AST with Groups and Stars.\n       expr 1 1 => expr\n       expr 0 1 => Choice(expr, Eps)\n       expr 0 3 => Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps)\n       expr 2 5 => EachOf(expr, expr, Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps))\n       expr 0 * => KleeneStar(expr)\n       expr 1 * => EachOf(expr, KleeneStar(expr))\n       expr 2 * => EachOf(expr, expr, KleeneStar(expr))\n\n       @@TODO: favor Plus over Star if Epsilon not in expr.\n    */\n    function _repeat (expr, min, max) {\n      if (min === undefined) { min = 1; }\n      if (max === undefined) { max = 1; }\n\n      if (min === 1 && max === 1) { return expr; }\n\n      var opts = max === UNBOUNDED ?\n        new KleeneStar(expr) :\n        _seq(max - min).reduce(function (ret, elt, ord) {\n          return ord === 0 ?\n            new Choice([expr, new Epsilon]) :\n            new Choice([new EachOf([expr, ret]), new Epsilon]);\n        }, undefined);\n\n      var reqd = min !== 0 ?\n        new EachOf(_seq(min).map(function (ret) {\n          return expr; // @@ something with ret\n        }).concat(opts)) : opts;\n      return reqd;\n    }\n\n    if (typeof expr === \"string\") { // Inclusion\n      var included = schema._index.tripleExprs[expr].expression;\n      return _compileExpression(included, schema);\n    }\n\n    else if (expr.type === \"TripleConstraint\") {\n      // predicate, inverse, negated, valueExpr, annotations, semActs, min, max\n      var valueExpr = \"valueExprRef\" in expr ?\n        schema.valueExprDefns[expr.valueExprRef] :\n        expr.valueExpr;\n      var ordinal = tripleConstraints.push(expr)-1;\n      var tp = new TripleConstraint(ordinal, expr.predicate, expr.inverse, expr.negated, valueExpr);\n      repeated = _repeat(tp, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"OneOf\") {\n      container = new Choice(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else if (expr.type === \"EachOf\") {\n      container = new EachOf(expr.expressions.map(function (e) {\n        return _compileExpression(e, schema);\n      }));\n      repeated = _repeat(container, expr.min, expr.max);\n      return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n    }\n\n    else throw Error(\"unexpected expr type: \" + expr.type);\n  }\n\n  return expression ? _compileExpression(expression, schema) : new Epsilon();\n}\n\n// http://stackoverflow.com/questions/9422386/lazy-cartesian-product-of-arrays-arbitrary-nested-loops\nfunction crossProduct(sets) {\n  var n = sets.length, carets = [], args = null;\n\n  function init() {\n    args = [];\n    for (var i = 0; i < n; i++) {\n      carets[i] = 0;\n      args[i] = sets[i][0];\n    }\n  }\n\n  function next() {\n\n    // special case: crossProduct([]).next().next() returns false.\n    if (args !== null && args.length === 0)\n      return false;\n\n    if (args === null) {\n      init();\n      return true;\n    }\n    var i = n - 1;\n    carets[i]++;\n    if (carets[i] < sets[i].length) {\n      args[i] = sets[i][carets[i]];\n      return true;\n    }\n    while (carets[i] >= sets[i].length) {\n      if (i == 0) {\n        return false;\n      }\n      carets[i] = 0;\n      args[i] = sets[i][0];\n      carets[--i]++;\n    }\n    args[i] = sets[i][carets[i]];\n    return true;\n  }\n\n  return {\n    next: next,\n    do: function (block, _context) { // old API\n      return block.apply(_context, args);\n    },\n    // new API because\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description\n    // cautions about functions over arguments.\n    get: function () { return args; }\n  };\n}\n\n/* N3jsTripleToString - simple toString function to make N3.js's triples\n * printable.\n */\nvar N3jsTripleToString = function () {\n  function fmt (n) {\n    return RdfTerm.isLiteral(n) ?\n      [ \"http://www.w3.org/2001/XMLSchema#integer\",\n        \"http://www.w3.org/2001/XMLSchema#float\",\n        \"http://www.w3.org/2001/XMLSchema#double\"\n      ].indexOf(RdfTerm.getLiteralType(n)) !== -1 ?\n      parseInt(RdfTerm.getLiteralValue(n)) :\n      n :\n    RdfTerm.isBlank(n) ?\n      n :\n      \"<\" + n + \">\";\n  }\n  return fmt(this.subject) + \" \" + fmt(this.predicate) + \" \" + fmt(this.object) + \" .\";\n};\n\n/* indexNeighborhood - index triples by predicate\n * returns: {\n *     byPredicate: Object: mapping from predicate to triples containing that\n *                  predicate.\n *\n *     candidates: [[1,3], [0,2]]: mapping from triple to the triple constraints\n *                 it matches.  It is initialized to []. Mappings that remain an\n *                 empty set indicate a triple which didn't matching anything in\n *                 the shape.\n *\n *     misses: list to recieve value constraint failures.\n *   }\n */\nfunction indexNeighborhood (triples) {\n  return {\n    byPredicate: triples.reduce(function (ret, t) {\n      var p = t.predicate;\n      if (!(p in ret))\n        ret[p] = [];\n      ret[p].push(t);\n\n      // If in VERBOSE mode, add a nice toString to N3.js's triple objects.\n      if (VERBOSE)\n        t.toString = N3jsTripleToString;\n\n      return ret;\n    }, {}),\n    candidates: _seq(triples.length).map(function () {\n      return [];\n    }),\n    misses: []\n  };\n}\n\n/* sparqlOrder - sort triples by subject following SPARQL partial ordering.\n */\nfunction sparqlOrder (l, r) {\n  var [lprec, rprec] = [l, r].map(\n    x => RdfTerm.isBlank(x) ? 1 : RdfTerm.isLiteral(x) ? 2 : 3\n  );\n  return lprec === rprec ? l.localeCompare(r) : lprec - rprec;\n}\n\n/* Return a list of n \"\"s.\n *\n * Note that Array(n) on its own returns a \"sparse array\" so Array(n).map(f)\n * never calls f.\n */\nfunction _seq (n) {\n  return n === 0 ?\n    [] :\n    Array(n).join(\" \").split(/ /); // hahaha, javascript, you suck.\n}\n\n/* Expect property p with value v in object o\n */\nfunction expect (o, p, v) {\n  if (!(p in o))\n    runtimeError(\"expected \"+JSON.stringify(o)+\" to have a '\"+p+\"' attribute.\");\n  if (arguments.length > 2 && o[p] !== v)\n    runtimeError(\"expected \"+p+\" attribute '\"+o[p]+\"' to equal '\"+v+\"'.\");\n}\n\nfunction noop () {  }\n\nfunction runtimeError () {\n  var errorStr = Array.prototype.join.call(arguments, \"\");\n  var e = new Error(errorStr);\n  Error.captureStackTrace(e, runtimeError);\n  throw e;\n}\n\n  return {\n    construct: ShExValidator_constructor,\n    start: Start,\n    options: InterfaceOptions\n  };\n})();\n\n// Export the `ShExValidator` class as a whole.\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = ShExValidator;\n"
    },
    {
      "id": 3,
      "identifier": "/tmp/npmz/shex-validator-user/node_modules/process/browser.js",
      "name": "./node_modules/process/browser.js",
      "index": 2,
      "index2": 0,
      "size": 5418,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerId": 2,
      "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerPath": [
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "profile": {
            "factory": 19,
            "building": 9
          }
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "profile": {
            "factory": 5,
            "building": 67
          }
        }
      ],
      "profile": {
        "factory": 32,
        "building": 20,
        "dependencies": 23
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "type": "cjs require",
          "userRequest": "process",
          "loc": "1:0-84"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 2,
      "source": "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"
    },
    {
      "id": 4,
      "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
      "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-visitor/shex-visitor.js",
      "index": 4,
      "index2": 2,
      "size": 13166,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerId": 2,
      "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerPath": [
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "profile": {
            "factory": 19,
            "building": 9
          }
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "profile": {
            "factory": 5,
            "building": 67
          }
        }
      ],
      "profile": {
        "factory": 32,
        "building": 20,
        "dependencies": 23
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "type": "cjs require",
          "userRequest": "@shexjs/visitor",
          "loc": "32:18-44"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 2,
      "source": "\n    function isTerm (t) {\n      return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce((r, k) => {\n        return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n      }, true);\n    }\n\n  function isShapeRef (expr) {\n    return typeof expr === \"string\" // test for JSON-LD @ID\n  }\n  let isInclusion = isShapeRef;\n\n\nfunction ShExVisitor () {\n  // function expect (l, r) { var ls = JSON.stringify(l), rs = JSON.stringify(r); if (ls !== rs) throw Error(ls+\" !== \"+rs); }\n  var _ShExUtil = this;\n  function visitMap (map, val) {\n    var ret = {};\n    Object.keys(map).forEach(function (item) {\n      ret[item] = val(map[item]);\n    });\n    return ret;\n  }\n  var r = {\n    runtimeError: function (e) {\n      throw e;\n    },\n\n    visitSchema: function (schema) {\n      var ret = { type: \"Schema\" };\n      _expect(schema, \"type\", \"Schema\");\n      this._maybeSet(schema, ret, \"Schema\",\n                     [\"@context\", \"prefixes\", \"base\", \"imports\", \"startActs\", \"start\", \"shapes\"],\n                     [\"_base\", \"_prefixes\", \"_index\", \"_sourceMap\"]\n                    );\n      return ret;\n    },\n\n    visitPrefixes: function (prefixes) {\n      return prefixes === undefined ?\n        undefined :\n        visitMap(prefixes, function (val) {\n          return val;\n        });\n    },\n\n    visitIRI: function (i) {\n      return i;\n    },\n\n    visitImports: function (imports) {\n      var _Visitor = this;\n      return imports.map(function (imp) {\n        return _Visitor.visitIRI(imp);\n      });\n    },\n\n    visitStartActs: function (startActs) {\n      var _Visitor = this;\n      return startActs === undefined ?\n        undefined :\n        startActs.map(function (act) {\n          return _Visitor.visitSemAct(act);\n        });\n    },\n    visitSemActs: function (semActs) {\n      var _Visitor = this;\n      if (semActs === undefined)\n        return undefined;\n      var ret = []\n      Object.keys(semActs).forEach(function (label) {\n        ret.push(_Visitor.visitSemAct(semActs[label], label));\n      });\n      return ret;\n    },\n    visitSemAct: function (semAct, label) {\n      var ret = { type: \"SemAct\" };\n      _expect(semAct, \"type\", \"SemAct\");\n\n      this._maybeSet(semAct, ret, \"SemAct\",\n                     [\"name\", \"code\"]);\n      return ret;\n    },\n\n    visitShapes: function (shapes) {\n      var _Visitor = this;\n      if (shapes === undefined)\n        return undefined;\n      return shapes.map(\n        shapeExpr =>\n          _Visitor.visitShapeExpr(shapeExpr)\n      );\n    },\n\n    visitProductions999: function (productions) { // !! DELETE\n      var _Visitor = this;\n      if (productions === undefined)\n        return undefined;\n      var ret = {}\n      Object.keys(productions).forEach(function (label) {\n        ret[label] = _Visitor.visitExpression(productions[label], label);\n      });\n      return ret;\n    },\n\n    visitShapeExpr: function (expr, label) {\n      if (isShapeRef(expr))\n        return this.visitShapeRef(expr)\n      var r =\n          expr.type === \"Shape\" ? this.visitShape(expr, label) :\n          expr.type === \"NodeConstraint\" ? this.visitNodeConstraint(expr, label) :\n          expr.type === \"ShapeAnd\" ? this.visitShapeAnd(expr, label) :\n          expr.type === \"ShapeOr\" ? this.visitShapeOr(expr, label) :\n          expr.type === \"ShapeNot\" ? this.visitShapeNot(expr, label) :\n          expr.type === \"ShapeExternal\" ? this.visitShapeExternal(expr) :\n          null;// if (expr.type === \"ShapeRef\") r = 0; // console.warn(\"visitShapeExpr:\", r);\n      if (r === null)\n        throw Error(\"unexpected shapeExpr type: \" + expr.type);\n      else\n        return r;\n    },\n\n    // _visitShapeGroup: visit a grouping expression (shapeAnd, shapeOr)\n    _visitShapeGroup: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExprs\"], expr.type, this.visitShapeNot)\n      var _Visitor = this;\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExprs = expr.shapeExprs.map(function (nested) {\n        return _Visitor.visitShapeExpr(nested, label);\n      });\n      return r;\n    },\n\n    // _visitShapeNot: visit negated shape\n    visitShapeNot: function (expr, label) {\n      this._testUnknownAttributes(expr, [\"id\", \"shapeExpr\"], \"ShapeNot\", this.visitShapeNot)\n      var r = { type: expr.type };\n      if (\"id\" in expr)\n        r.id = expr.id;\n      r.shapeExpr = this.visitShapeExpr(expr.shapeExpr, label);\n      return r;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitShape: function (shape, label) {\n      var ret = { type: \"Shape\" };\n      _expect(shape, \"type\", \"Shape\");\n\n      this._maybeSet(shape, ret, \"Shape\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"closed\",\n                       \"expression\", \"extra\", \"semActs\", \"annotations\"]);\n      return ret;\n    },\n\n    // ### `visitNodeConstraint` deep-copies the structure of a shape\n    visitNodeConstraint: function (shape, label) {\n      var ret = { type: \"NodeConstraint\" };\n      _expect(shape, \"type\", \"NodeConstraint\");\n\n      this._maybeSet(shape, ret, \"NodeConstraint\",\n                     [ \"id\",\n                       // \"virtual\", \"inherit\", -- futureWork\n                       \"nodeKind\", \"datatype\", \"pattern\", \"flags\", \"length\",\n                       \"reference\", \"minlength\", \"maxlength\",\n                       \"mininclusive\", \"minexclusive\", \"maxinclusive\", \"maxexclusive\",\n                       \"totaldigits\", \"fractiondigits\", \"values\", \"annotations\", \"semActs\"]);\n      return ret;\n    },\n\n    visitShapeRef: function (reference) {\n      if (typeof reference !== \"string\") {\n        let ex = Exception(\"visitShapeRef expected a string, not \" + JSON.stringify(reference));\n        console.warn(ex);\n        throw ex;\n      }\n      return reference;\n    },\n\n    visitShapeExternal: function (expr) {\n      this._testUnknownAttributes(expr, [\"id\"], \"ShapeExternal\", this.visitShapeNot)\n      return Object.assign(\"id\" in expr ? { id: expr.id } : {}, { type: \"ShapeExternal\" });\n    },\n\n    // _visitGroup: visit a grouping expression (someOf or eachOf)\n    _visitGroup: function (expr, type) {\n      var _Visitor = this;\n      var r = Object.assign(\n        // pre-declare an id so it sorts to the top\n        \"id\" in expr ? { id: null } : { },\n        { type: expr.type }\n      );\n      r.expressions = expr.expressions.map(function (nested) {\n        return _Visitor.visitExpression(nested);\n      });\n      return this._maybeSet(expr, r, \"expr\",\n                            [\"id\", \"min\", \"max\", \"annotations\", \"semActs\"], [\"expressions\"]);\n    },\n\n    visitTripleConstraint: function (expr) {\n      return this._maybeSet(expr,\n                            Object.assign(\n                              // pre-declare an id so it sorts to the top\n                              \"id\" in expr ? { id: null } : { },\n                              { type: \"TripleConstraint\" }\n                            ),\n                            \"TripleConstraint\",\n                            [\"id\", \"inverse\", \"predicate\", \"valueExpr\",\n                             \"min\", \"max\", \"annotations\", \"semActs\"])\n    },\n\n    visitExpression: function (expr) {\n      if (typeof expr === \"string\")\n        return this.visitInclusion(expr);\n      var r = expr.type === \"TripleConstraint\" ? this.visitTripleConstraint(expr) :\n          expr.type === \"OneOf\" ? this.visitOneOf(expr) :\n          expr.type === \"EachOf\" ? this.visitEachOf(expr) :\n          null;\n      if (r === null)\n        throw Error(\"unexpected expression type: \" + expr.type);\n      else\n        return r;\n    },\n\n    visitValues: function (values) {\n      var _Visitor = this;\n      return values.map(function (t) {\n        return isTerm(t) || t.type === \"Language\" ?\n          t :\n          _Visitor.visitStemRange(t);\n      });\n    },\n\n    visitStemRange: function (t) {\n      var _Visitor = this; // console.log(Error(t.type).stack);\n      // _expect(t, \"type\", \"IriStemRange\");\n      if (!(\"type\" in t))\n        _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(t)+\" to have a 'type' attribute.\"));\n      var stemRangeTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n      if (stemRangeTypes.indexOf(t.type) === -1)\n        _Visitor.runtimeError(Error(\"expected type attribute '\"+t.type+\"' to be in '\"+stemRangeTypes+\"'.\"));\n      var stem;\n      if (isTerm(t)) {\n        _expect(t.stem, \"type\", \"Wildcard\");\n        stem = { type: t.type, stem: { type: \"Wildcard\" } };\n      } else {\n        stem = { type: t.type, stem: t.stem };\n      }\n      if (t.exclusions) {\n        stem.exclusions = t.exclusions.map(function (c) {\n          return _Visitor.visitExclusion(c);\n        });\n      }\n      return stem;\n    },\n\n    visitExclusion: function (c) {\n      if (!isTerm(c)) {\n        // _expect(c, \"type\", \"IriStem\");\n        if (!(\"type\" in c))\n          _Visitor.runtimeError(Error(\"expected \"+JSON.stringify(c)+\" to have a 'type' attribute.\"));\n        var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n        if (stemTypes.indexOf(c.type) === -1)\n          _Visitor.runtimeError(Error(\"expected type attribute '\"+c.type+\"' to be in '\"+stemTypes+\"'.\"));\n        return { type: c.type, stem: c.stem };\n      } else {\n        return c;\n      }\n    },\n\n    visitInclusion: function (inclusion) {\n      if (typeof inclusion !== \"string\") {\n        let ex = Exception(\"visitInclusion expected a string, not \" + JSON.stringify(inclusion));\n        console.warn(ex);\n        throw ex;\n      }\n      return inclusion;\n    },\n\n    _maybeSet: function (obj, ret, context, members, ignore) {\n      var _Visitor = this;\n      this._testUnknownAttributes(obj, ignore ? members.concat(ignore) : members, context, this._maybeSet)\n      members.forEach(function (member) {\n        var methodName = \"visit\" + member.charAt(0).toUpperCase() + member.slice(1);\n        if (member in obj) {\n          var f = _Visitor[methodName];\n          if (typeof f !== \"function\") {\n            throw Error(methodName + \" not found in Visitor\");\n          }\n          var t = f.call(_Visitor, obj[member]);\n          if (t !== undefined) {\n            ret[member] = t;\n          }\n        }\n      });\n      return ret;\n    },\n    _visitValue: function (v) {\n      return v;\n    },\n    _visitList: function (l) {\n      return l.slice();\n    },\n    _testUnknownAttributes: function (obj, expected, context, captureFrame) {\n      var unknownMembers = Object.keys(obj).reduce(function (ret, k) {\n        return k !== \"type\" && expected.indexOf(k) === -1 ? ret.concat(k) : ret;\n      }, []);\n      if (unknownMembers.length > 0) {\n        var e = Error(\"unknown propert\" + (unknownMembers.length > 1 ? \"ies\" : \"y\") + \": \" +\n                      unknownMembers.map(function (p) {\n                        return \"\\\"\" + p + \"\\\"\";\n                      }).join(\",\") +\n                      \" in \" + context + \": \" + JSON.stringify(obj));\n        Error.captureStackTrace(e, captureFrame);\n        throw e;\n      }\n    }\n\n  };\n  r.visitBase = r.visitStart = r.visitVirtual = r.visitClosed = r[\"visit@context\"] = r._visitValue;\n  r.visitInherit = r.visitExtra = r.visitAnnotations = r._visitList;\n  r.visitInverse = r.visitPredicate = r._visitValue;\n  r.visitName = r.visitId = r.visitCode = r.visitMin = r.visitMax = r._visitValue;\n\n  r.visitType = r.visitNodeKind = r.visitDatatype = r.visitPattern = r.visitFlags = r.visitLength = r.visitMinlength = r.visitMaxlength = r.visitMininclusive = r.visitMinexclusive = r.visitMaxinclusive = r.visitMaxexclusive = r.visitTotaldigits = r.visitFractiondigits = r._visitValue;\n  r.visitOneOf = r.visitEachOf = r._visitGroup;\n  r.visitShapeAnd = r.visitShapeOr = r._visitShapeGroup;\n  r.visitInclude = r._visitValue;\n  r.visitValueExpr = r.visitShapeExpr;\n  return r;\n\n  // Expect property p with value v in object o\n  function _expect (o, p, v) {\n    if (!(p in o))\n      this._error(\"expected \"+JSON.stringify(o)+\" to have a .\"+p);\n    if (arguments.length > 2 && o[p] !== v)\n      this._error(\"expected \"+o[o]+\" to equal .\"+v);\n  }\n\n  function _error (str) {\n    throw new Error(str);\n  }\n}\n\n// The ShEx Vistor is here to minimize deps for ShExValidator.\n/** create indexes for schema\n */\nShExVisitor.index = function (schema) {\n  let index = {\n    shapeExprs: {},\n    tripleExprs: {}\n  };\n  let v = ShExVisitor();\n\n  let oldVisitExpression = v.visitExpression;\n  v.visitExpression = function (expression) {\n    if (typeof expression === \"object\" && \"id\" in expression)\n      index.tripleExprs[expression.id] = expression;\n    return oldVisitExpression.call(v, expression);\n  };\n\n  let oldVisitShapeExpr = v.visitShapeExpr;\n  v.visitShapeExpr = v.visitValueExpr = function (shapeExpr, label) {\n    if (typeof shapeExpr === \"object\" && \"id\" in shapeExpr)\n      index.shapeExprs[shapeExpr.id] = shapeExpr;\n    return oldVisitShapeExpr.call(v, shapeExpr, label);\n  };\n\n  v.visitSchema(schema);\n  return index;\n}\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined')\n  module.exports = ShExVisitor;\n\n"
    },
    {
      "id": 5,
      "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
      "name": "/tmp/checkouts/shexSpec/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr.js",
      "index": 5,
      "index2": 3,
      "size": 15295,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0,
        1
      ],
      "issuer": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerId": 2,
      "issuerName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
      "issuerPath": [
        {
          "id": 1,
          "identifier": "/tmp/npmz/shex-validator-user/shex-validator-user.js",
          "name": "./shex-validator-user.js",
          "profile": {
            "factory": 19,
            "building": 9
          }
        },
        {
          "id": 2,
          "identifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "name": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "profile": {
            "factory": 5,
            "building": 67
          }
        }
      ],
      "profile": {
        "factory": 32,
        "building": 20,
        "dependencies": 23
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "assets": [],
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "module": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "moduleName": "/tmp/checkouts/shexSpec/shex.js/packages/shex-validator/shex-validator.js",
          "type": "cjs require",
          "userRequest": "@shexjs/eval-threaded-nerr",
          "loc": "245:48-85"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [
        "ModuleConcatenation bailout: Module is not an ECMAScript module"
      ],
      "depth": 2,
      "source": "var EvalThreadedNErr = (function () {\nvar RdfTerm = require(\"@shexjs/term\");\nvar UNBOUNDED = -1;\n\nfunction vpEngine (schema, shape, index) {\n    var outerExpression = shape.expression;\n    return {\n      match:match\n    };\n\n    function match (graph, node, constraintList, constraintToTripleMapping, tripleToConstraintMapping, neighborhood, recurse, direct, semActHandler, checkValueExpr, trace) {\n\n      /*\n       * returns: list of passing or failing threads (no heterogeneous lists)\n       */\n      function validateExpr (expr, thread) {\n        if (typeof expr === \"string\") { // Inclusion\n          var included = index.tripleExprs[expr];\n          return validateExpr(included, thread);\n        }\n\n        var constraintNo = constraintList.indexOf(expr);\n        var min = \"min\" in expr ? expr.min : 1;\n        var max = \"max\" in expr ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n\n        function validateRept (type, val) {\n          var repeated = 0, errOut = false;\n          var newThreads = [thread];\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          for (; repeated < max && !errOut; ++repeated) {\n            var inner = [];\n            for (var t = 0; t < newThreads.length; ++t) {\n              var newt = newThreads[t];\n              var sub = val(newt);\n              if (sub.length > 0 && sub[0].errors.length === 0) {\n                sub.forEach(newThread => {\n                  var solutions =\n                      \"expression\" in newt ? newt.expression.solutions : [];\n                  if (\"solution\" in newThread)\n                    solutions = solutions.concat(newThread.solution);\n                  delete newThread.solution;\n                  newThread.expression = extend({\n                    type: type,\n                    solutions: solutions\n                  }, minmax);\n                });\n              }\n              if (sub.length === 0 /* min:0 */ || sub[0].errors.length > 0)\n                return repeated < min ? sub : newThreads;\n              else\n                inner = inner.concat(sub);\n              // newThreads.expressions.push(sub);\n            }\n            newThreads = inner;\n          }\n          if (newThreads.length > 0 && newThreads[0].errors.length === 0 && \"semActs\" in expr) {\n            var passes = [];\n            var failures = [];\n            newThreads.forEach(newThread => {\n              const semActErrors = semActHandler.dispatchAll(expr.semActs, \"???\", newThread)\n              if (semActErrors.length === 0) {\n                passes.push(newThread)\n              } else {\n                [].push.apply(newThread.errors, semActErrors);\n                failures.push(newThread);\n              }\n            });\n            newThreads = passes.length > 0 ? passes : failures;\n          }\n          return newThreads;\n        }\n\n        if (expr.type === \"TripleConstraint\") {\n          var negated = \"negated\" in expr && expr.negated || max === 0;\n          if (negated)\n            min = max = Infinity;\n          if (thread.avail[constraintNo] === undefined)\n            thread.avail[constraintNo] = constraintToTripleMapping[constraintNo].slice();\n          var minmax = {  };\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n          if (\"semActs\" in expr)\n            minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr)\n            minmax.annotations = expr.annotations;\n          var taken = thread.avail[constraintNo].splice(0, min);\n          var passed = negated ? taken.length === 0 : taken.length >= min;\n          var ret = [];\n          var matched = thread.matched;\n          if (passed) {\n            do {\n              ret.push({\n                avail: thread.avail.map(a => { // copy parent thread's avail vector\n                  return a.slice();\n                }), // was: extend({}, thread.avail)\n                errors: thread.errors.slice(),\n                matched: matched.concat({\n                  tNos: taken.slice()\n                }),\n                expression: extend(\n                  {\n                    type: \"TripleConstraintSolutions\",\n                    predicate: expr.predicate,\n                    solutions: taken.map(tripleNo =>  {\n                      return { type: \"halfTestedTriple\", tripleNo: tripleNo, constraintNo: constraintNo };\n                    })\n                    // map(triple => {\n                    //   var t = neighborhood[triple];\n                    //   return {\n                    //     type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: t.object\n                    //   }\n                    // })\n                  },\n                  \"valueExpr\" in expr ? { valueExpr: expr.valueExpr } : {},\n                  \"productionLabel\" in expr ? { productionLabel: expr.productionLabel } : {},\n                  minmax)\n              });\n            } while ((function () {\n              if (thread.avail[constraintNo].length > 0 && taken.length < max) {\n                taken.push(thread.avail[constraintNo].shift());\n                return true;\n              } else {\n                return false;\n              }\n            })());\n          } else {\n            var valueExpr = null;\n            if (typeof expr.valueExpr === \"string\") { // ShapeRef\n              valueExpr = expr.valueExpr;\n              if (RdfTerm.isBlank(valueExpr))\n                valueExpr = index.shapeExprs[valueExpr];\n            } else if (expr.valueExpr) {\n              valueExpr = extend({}, expr.valueExpr)\n            }\n            ret.push({\n              avail: thread.avail,\n              errors: thread.errors.concat([\n                extend({\n                  type: negated ? \"NegatedProperty\" : \"MissingProperty\",\n                  property: expr.predicate\n                }, valueExpr ? { valueExpr: valueExpr } : {})\n              ]),\n              matched: matched\n            });\n          }\n\n          return ret;\n        }\n\n        else if (expr.type === \"OneOf\") {\n          return validateRept(\"OneOfSolutions\", (th) => {\n            var accept = null;\n            var matched = [];\n            var failed = [];\n            expr.expressions.forEach(nested => {\n              var thcopy = {\n                avail: th.avail.map(a => { return a.slice(); }),\n                errors: th.errors,\n                matched: th.matched//.slice() ever needed??\n              };\n              var sub = validateExpr(nested, thcopy);\n              if (sub[0].errors.length === 0) {\n                matched = matched.concat(sub);\n                sub.forEach(newThread => {\n                  var expressions =\n                      \"solution\" in thcopy ? thcopy.solution.expressions : [];\n                  if (\"expression\" in newThread) // undefined for no matches on min card:0\n                    expressions = expressions.concat([newThread.expression]);\n                  delete newThread.expression;\n                  newThread.solution = {\n                    type: \"OneOfSolution\",\n                    expressions: expressions\n                  };\n                });\n              } else\n                failed = failed.concat(sub);\n            });\n            return matched.length > 0 ? matched : failed;\n          });\n        }\n\n        else if (expr.type === \"EachOf\") {\n          return validateRept(\"EachOfSolutions\", (th) => {\n            // Iterate through nested expressions, exprThreads starts as [th].\n            return expr.expressions.reduce((exprThreads, nested) => {\n              // Iterate through current thread list composing nextThreads.\n              // Consider e.g.\n              // <S1> { <p1> . | <p2> .; <p3> . } / { <x> <p2> 2; <p3> 3 } (should pass)\n              // <S1> { <p1> .; <p2> . }          / { <s1> <p1> 1 }        (should fail)\n              return exprThreads.reduce((nextThreads, exprThread) => {\n                var sub = validateExpr(nested, exprThread);\n                // Move newThread.expression into a hierarchical solution structure.\n                sub.forEach(newThread => {\n                  if (newThread.errors.length === 0) {\n                    var expressions =\n                        \"solution\" in exprThread ? exprThread.solution.expressions : [];\n                    if (\"expression\" in newThread) // undefined for no matches on min card:0\n                      expressions = expressions.concat([newThread.expression]);\n                    // console.warn(threadMatched(newThread), \" vs \", exprMatched(expressions));\n                    delete newThread.expression;\n                    newThread.solution = {\n                      type: \"EachOfSolution\",\n                      expressions: expressions // exprThread.expression + newThread.expression\n                    };\n                  }\n                });\n                return nextThreads.concat(sub);\n              }, []);\n            }, [th]);\n          });\n        }\n\n        runtimeError(\"unexpected expr type: \" + expr.type);\n      }\n\n      var startingThread = {\n        avail:[],   // triples remaining by constraint number\n        matched:[], // triples matched in this thread\n        errors:[]   // errors encounted\n      };\n      if (!outerExpression)\n        return { }; // vapid match if no expression\n      var ret = validateExpr(outerExpression, startingThread);\n      // console.log(JSON.stringify(ret));\n      // note: don't return if ret.length === 1 because it might fail the unmatchedTriples test.\n      var longerChosen =\n          ret.reduce((ret, elt) => {\n            if (elt.errors.length > 0)\n              return ret;              // early return\n            var unmatchedTriples = {};\n            // Collect triples assigned to some constraint.\n            Object.keys(tripleToConstraintMapping).forEach(k => {\n              if (tripleToConstraintMapping[k] !== undefined)\n                unmatchedTriples[k] = tripleToConstraintMapping[k];\n            });\n            // Removed triples matched in this thread.\n            elt.matched.forEach(m => {\n              m.tNos.forEach(t => {\n                delete unmatchedTriples[t];\n              });\n            });\n            // Remaining triples are unaccounted for.\n            Object.keys(unmatchedTriples).forEach(t => {\n              elt.errors.push({\n                type: \"ExcessTripleViolation\",\n                triple: neighborhood[t],\n                constraint: constraintList[unmatchedTriples[t]]\n              });\n            });\n            return ret !== null ? ret : // keep first solution\n            // Accept thread with no unmatched triples.\n            Object.keys(unmatchedTriples).length > 0 ? null : elt;\n          }, null);\n      return longerChosen !== null ?\n        finish(longerChosen.expression, constraintList,\n               neighborhood, recurse, direct, semActHandler, checkValueExpr) :\n        ret.length > 1 ? {\n          type: \"PossibleErrors\",\n          errors: ret.reduce((all, e) => {\n            return all.concat([e.errors]);\n          }, [])\n        } : ret[0];\n    }\n\n    function finish (fromValidatePoint, constraintList, neighborhood, recurse, direct, semActHandler, checkValueExpr) {\n      function _dive (solns) {\n        function ldify (term) {\n          if (term[0] !== \"\\\"\")\n            return term;\n          var ret = { value: RdfTerm.getLiteralValue(term) };\n          var dt = RdfTerm.getLiteralType(term);\n          if (dt &&\n              dt !== \"http://www.w3.org/2001/XMLSchema#string\" &&\n              dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\")\n            ret.type = dt;\n          var lang = RdfTerm.getLiteralLanguage(term)\n          if (lang)\n            ret.language = lang;\n          return ret;\n        }\n        if (solns.type === \"OneOfSolutions\" ||\n            solns.type === \"EachOfSolutions\") {\n          solns.solutions.forEach(s => {\n            s.expressions.forEach(e => {\n              _dive(e);\n            });\n          });\n        } else if (solns.type === \"TripleConstraintSolutions\") {\n          solns.solutions = solns.solutions.map(x => {\n            if (x.type === \"TestedTriple\") // already done\n              return x; // c.f. validation/3circularRef1_pass-open\n            var t = neighborhood[x.tripleNo];\n            var expr = constraintList[x.constraintNo];\n            var ret = {\n              type: \"TestedTriple\", subject: t.subject, predicate: t.predicate, object: ldify(t.object)\n            };\n            function diver (focus, shapeLabel, dive) {\n              var sub = dive(focus, shapeLabel);\n              if (\"errors\" in sub) {\n                // console.dir(sub);\n                var err = {\n                  type: \"ReferenceError\", focus: focus,\n                  shape: shapeLabel\n                };\n                if (typeof shapeLabel === \"string\" && RdfTerm.isBlank(shapeLabel))\n                  err.referencedShape = shape;\n                err.errors = sub;\n                return [err];\n              }\n              if ((\"solution\" in sub || \"solutions\" in sub)&& Object.keys(sub.solution || sub.solutions).length !== 0 ||\n                  sub.type === \"Recursion\")\n                ret.referenced = sub; // !!! needs to aggregate errors and solutions\n              return [];\n            }\n            function diveRecurse (focus, shapeLabel) {\n              return diver(focus, shapeLabel, recurse);\n            }\n            function diveDirect (focus, shapeLabel) {\n              return diver(focus, shapeLabel, direct);\n            }\n            var subErrors = \"valueExpr\" in expr ?\n                checkValueExpr(expr.inverse ? t.subject : t.object, expr.valueExpr, diveRecurse, diveDirect) :\n                [];\n            if (subErrors.length === 0 && \"semActs\" in expr)\n              [].push.apply(subErrors, semActHandler.dispatchAll(expr.semActs, t, ret))\n            if (subErrors.length > 0) {\n              fromValidatePoint.errors = fromValidatePoint.errors || [];\n              fromValidatePoint.errors = fromValidatePoint.errors.concat(subErrors);\n            }\n            return ret;\n          });\n        } else {\n          throw Error(\"unexpected expr type in \" + JSON.stringify(solns));\n        }\n      }\n      if (Object.keys(fromValidatePoint).length > 0) // guard against {}\n        _dive(fromValidatePoint);\n      if (\"semActs\" in shape)\n        fromValidatePoint.semActs = shape.semActs;\n      return fromValidatePoint;\n    }\n  }\n\nfunction extend(base) {\n  if (!base) base = {};\n  for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)\n    for (var name in arg)\n      base[name] = arg[name];\n  return base;\n}\n\nreturn {\n  name: \"eval-threaded-nerr\",\n  description: \"emulation of regular expression engine with error permutations\",\n  compile: vpEngine\n};\n})();\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\")\n  module.exports = EvalThreadedNErr;\n"
    }
  ],
  "filteredModules": 0,
  "logging": {
    "webpack.buildChunkGraph.visitModules": {
      "entries": [],
      "filteredEntries": 2,
      "debug": false
    }
  },
  "children": []
}
